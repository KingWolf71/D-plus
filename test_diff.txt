================================================================================
LJ2 Test Diff Report - 2025-12-05 08:25:19
================================================================================

Changed files: 25

--------------------------------------------------------------------------------
FILE: 01 comprehensive test1.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
LJ2 COMPREHENSIVE FEATURE TEST SUITE
-------------------------------------
SECTION 1: Data Types and Literals
-----------------------------------
Test: Positive integer literal assignment, Expected: 42
Test: testInt = 42
[PASS] assertEqual: 42 == 42
Test: Negative integer literal assignment, Expected: -17
Test: testNegInt = -17
[PASS] assertEqual: -17 == -17
Test: Zero integer literal assignment, Expected: 0
Test: testZero = 0
[PASS] assertEqual: 0 == 0
Test: Positive float literal assignment, Expected: 3.14159
Test: testFloat ~= 3.14159 (float)
[PASS] assertFloatEqual: 3.142 ~= 3.142 (tol=0.000)
Test: Negative float literal assignment, Expected: -2.718
Test: testNegFloat ~= -2.718 (float)
[PASS] assertFloatEqual: -2.718 ~= -2.718 (tol=0.000)
Test: Zero float literal assignment, Expected: 0.0
Test: testFloatZero ~= 0.0 (float)
[PASS] assertFloatEqual: 0.000 ~= 0.000 (tol=0.000)
Test: String literal assignment, Expected: Hello, World!
Hello (string)Test: World!Hello, World!
[PASS] assertStringEqual: "Hello, World!" == "Hello, World!"
Test: Empty string literal assignment, Expected: (empty)
Test: testEmptyStr = '' (string)
[PASS] assertStringEqual: "" == ""
SECTION 2: Arithmetic Operators
-------------------------------
Test: Integer addition (20 + 7), Expected: 27
Test: resultAdd = 27
[PASS] assertEqual: 27 == 27
Test: Integer subtraction (20 - 7), Expected: 13
Test: resultSub = 13
[PASS] assertEqual: 13 == 13
Test: Integer multiplication (20 * 7), Expected: 140
Test: resultMul = 140
[PASS] assertEqual: 140 == 140
Test: Integer division (20 / 7), Expected: 2
Test: resultDiv = 2
[PASS] assertEqual: 2 == 2
Test: Modulo operation (20 % 7), Expected: 6
Test: resultMod = 6
[PASS] assertEqual: 6 == 6
Test: Negative operand arithmetic (-10 + 5), Expected: -5
Test: negResult = -5
[PASS] assertEqual: -5 == -5
Test: Float multiplication (10.5 * 2.5), Expected: 26.25
Test: floatResult ~= 26.25 (float)
[PASS] assertFloatEqual: 26.250 ~= 26.250 (tol=0.000)
Test: Mixed int/float addition (10 + 2.5), Expected: 12.5
Test: mixedResult ~= 12.5 (float)
[PASS] assertFloatEqual: 12.500 ~= 12.500 (tol=0.000)
SECTION 3: Comparison Operators
-------------------------------
Test: Less than (10 < 20), Expected: 1
Test: testLT = 1
[PASS] assertEqual: 1 == 1
Test: Greater than (20 > 10), Expected: 1
Test: testGT = 1
[PASS] assertEqual: 1 == 1
Test: Less than or equal (10 <= 10), Expected: 1
Test: testLE = 1
[PASS] assertEqual: 1 == 1
Test: Greater than or equal (20 >= 10), Expected: 1
Test: testGE = 1
[PASS] assertEqual: 1 == 1
Test: Equality (10 == 10), Expected: 1
Test: testEQ = 1
[PASS] assertEqual: 1 == 1
Test: Inequality (10 != 20), Expected: 1
Test: testNE = 1
[PASS] assertEqual: 1 == 1
Test: Float equality (3.14 == 3.14), Expected: 1
Test: testFloatEQ = 1
[PASS] assertEqual: 1 == 1
SECTION 4: Logical Operators
----------------------------
Test: AND operator (5 < 15 && 15 < 25), Expected: 1
Test: testAND = 1
[PASS] assertEqual: 1 == 1
Test: OR operator (5 > 100 || 15 < 20), Expected: 1
Test: testOR = 1
[PASS] assertEqual: 1 == 1
Test: Complex logical ((5 < 15 && 15 < 25) || 5 == 5), Expected: 1
Test: testComplex = 1
[PASS] assertEqual: 1 == 1
Test: Nested conditions (true && true), Expected: 1
Test: testNestedResult = 1
[PASS] assertEqual: 1 == 1
SECTION 5: Control Flow - If/Else
----------------------------------
Simple if: PASS
If-else: PASS
Grade: B (correct for 85)
Can drive: YES (correct)
SECTION 6: Control Flow - While Loops
--------------------------------------
Count up 1-5: 
1 
2 
3 
4 
5 
Count down 10-7: 
10 
9 
8 
7 
Multiplication table (3x3):
1 
2 
3 
2 
4 
6 
3 
6 
9 
Sum until > 100: 
105 (first sum > 100)
SECTION 7: Functions - Basic
----------------------------
Test: Function with no parameters greet(), Expected: 42
Test: greeting = 42
[PASS] assertEqual: 42 == 42
Test: Function square(5), Expected: 25
Test: sq5 = 25
[PASS] assertEqual: 25 == 25
Test: Function add(7, 5), Expected: 12
Test: sum12 = 12
[PASS] assertEqual: 12 == 12
Test: Function volume(3, 4, 5), Expected: 60
Test: vol = 60
[PASS] assertEqual: 60 == 60
Test: Function divide(22, 7), Expected: 3
Test: divResult = 3
[PASS] assertEqual: 3 == 3
SECTION 8: Functions - Recursion
--------------------------------
Test: fact5 = 120
[PASS] assertEqual: 120 == 120
Test: fact7 = 5040
[PASS] assertEqual: 5040 == 5040
Test: fib8 = 21
[PASS] assertEqual: 21 == 21
Test: fib10 = 55
[PASS] assertEqual: 55 == 55
Test: digitSum = 15
[PASS] assertEqual: 15 == 15
SECTION 9: Functions - Nested Calls
-----------------------------------
Test: nested1 = 30
[PASS] assertEqual: 30 == 30
Test: nested2 = 24
[PASS] assertEqual: 24 == 24
Test: nested3 = 25
[PASS] assertEqual: 25 == 25
Test: nested4 = 46
[PASS] assertEqual: 46 == 46
SECTION 10: Functions - Multiple Returns
----------------------------------------
Test: class1 = -1
[PASS] assertEqual: -1 == -1
Test: class2 = 0
[PASS] assertEqual: 0 == 0
Test: class3 = 1
[PASS] assertEqual: 1 == 1
Test: found = 17
[PASS] assertEqual: 17 == 17
SECTION 11: Built-in Functions
------------------------------
Test: absNeg = 42
[PASS] assertEqual: 42 == 42
Test: absPos = 17
[PASS] assertEqual: 17 == 17
Test: absZero = 0
[PASS] assertEqual: 0 == 0
Test: minVal = 15
[PASS] assertEqual: 15 == 15
Test: minNeg = -10
[PASS] assertEqual: -10 == -10
Test: maxVal = 23
[PASS] assertEqual: 23 == 23
Test: maxNeg = -5
[PASS] assertEqual: -5 == -5
random(100): 7 (should be 0-99)
Test: nestedBuiltin = 10
[PASS] assertEqual: 10 == 10
SECTION 12: Local Variables
---------------------------
Test: resultLocal = 42
[PASS] assertEqual: 42 == 42
Test: globalX = 100
[PASS] assertEqual: 100 == 100
Test: resultParam = 10
[PASS] assertEqual: 10 == 10
Test: globalA = 999
[PASS] assertEqual: 999 == 999
Test: multiResult = 23
[PASS] assertEqual: 23 == 23
SECTION 13: Macros
------------------
Test: area ~= 78.53975 (float)
[PASS] assertFloatEqual: 78.540 ~= 78.540 (tol=0.000)
Test: testMacro = 1
[PASS] assertEqual: 1 == 1
SECTION 14: String Operations
-----------------------------
Concatenation: Hello World
Mixed: Value = 42
SECTION 15: Edge Cases and Stress Tests
---------------------------------------
Large number: 999999
Test: deepFact = 3628800
[PASS] assertEqual: 3628800 == 3628800
Test: sixSum = 21
[PASS] assertEqual: 21 == 21
Test: complex = 23
[PASS] assertEqual: 23 == 23
Test: deepNest = 24
[PASS] assertEqual: 24 == 24
SECTION 16: Optimization Tests
------------------------------
Test: constFold1 = 15
[PASS] assertEqual: 15 == 15
Test: constFold2 = 60
[PASS] assertEqual: 60 == 60
Test: identAdd = 42
[PASS] assertEqual: 42 == 42
Test: identMul = 42
[PASS] assertEqual: 42 == 42
Test: identSub = 42
[PASS] assertEqual: 42 == 42
Test: identDiv = 42
[PASS] assertEqual: 42 == 42
Test: identZero = 0
[PASS] assertEqual: 0 == 0
SECTION 17: Real-world Algorithms
---------------------------------
Test: gcdResult = 6
[PASS] assertEqual: 6 == 6
Test: prime17 = 1
[PASS] assertEqual: 1 == 1
Test: prime18 = 0
[PASS] assertEqual: 0 == 0
Test: pow2_10 = 1024
[PASS] assertEqual: 1024 == 1024
Test: pow3_4 = 81
[PASS] assertEqual: 81 == 81
SECTION 18: Type System and Automatic Conversion
------------------------------------------------
Int var: 42 (expected: 42)
Float var: 3.142 (expected: 3.14159)
String var: Hello (expected: Hello)
Test: sqInt = 25
[PASS] assertEqual: 25 == 25
Test: sqFloat ~= 6.25 (float)
[PASS] assertFloatEqual: 6.250 ~= 6.250 (tol=0.000)
Test: sqConverted = 9
[PASS] assertEqual: 9 == 9
Test: sqFloatConverted ~= 16.0 (float)
[PASS] assertFloatEqual: 16.000 ~= 16.000 (tol=0.000)
Test: assignFloat ~= 42.0 (float)
[PASS] assertFloatEqual: 42.000 ~= 42.000 (tol=0.000)
Test: assignIntVal = 9
[PASS] assertEqual: 9 == 9
Test: floatFromInt ~= 100.0 (float)
[PASS] assertFloatEqual: 100.000 ~= 100.000 (tol=0.000)
Test: intFromFloat = 2
[PASS] assertEqual: 2 == 2
Test: piAsInt = 3
[PASS] assertEqual: 3 == 3
Test: intAsFloat ~= 42.0 (float)
[PASS] assertFloatEqual: 42.000 ~= 42.000 (tol=0.000)
Test: chainResult ~= 8.0 (float)
[PASS] assertFloatEqual: 8.000 ~= 8.000 (tol=0.000)
Test: nestedConv = 15
[PASS] assertEqual: 15 == 15
SECTION 19: Ternary Operator
----------------------------
Test: ternary1 = 100
[PASS] assertEqual: 100 == 100
Test: ternary2 = 200
[PASS] assertEqual: 200 == 200
Test: ternMax = 20
[PASS] assertEqual: 20 == 20
Test: ternMin = 15
[PASS] assertEqual: 15 == 15
Test: nestedTern = 111
[PASS] assertEqual: 111 == 111
Test: ternExpr = 60
[PASS] assertEqual: 60 == 60
Test: ternZero = 999
[PASS] assertEqual: 999 == 999
Test: macroMax1 = 42
[PASS] assertEqual: 42 == 42
Test: macroMax2 = -5
[PASS] assertEqual: -5 == -5
Test: macroMin1 = 17
[PASS] assertEqual: 17 == 17
Test: floatTern1 ~= 5.5 (float)
[PASS] assertFloatEqual: 5.500 ~= 5.500 (tol=0.000)
Test: ternFunc = 20
[PASS] assertEqual: 20 == 20
Test: complexCond = 12
[PASS] assertEqual: 12 == 12
SECTION 20: Logical NOT Operator
--------------------------------
Test: notTrue = 1
[PASS] assertEqual: 1 == 1
Test: notFalse = 0
[PASS] assertEqual: 0 == 0
Test: notZero = 1
[PASS] assertEqual: 1 == 1
Test: notNonZero = 0
[PASS] assertEqual: 0 == 0
Test: notEqual = 0
[PASS] assertEqual: 0 == 0
Test: doubleNot = 1
[PASS] assertEqual: 1 == 1
Test: testNotComplex = 1
[PASS] assertEqual: 1 == 1
Test: testNotIneq = 1
[PASS] assertEqual: 1 == 1

========================================
  COMPREHENSIVE TEST SUITE COMPLETE
========================================

Note: Built-in assertions automatically report failures.
If you see this message, all tests passed!



+++ CURRENT OUTPUT +++
LJ2 COMPREHENSIVE FEATURE TEST SUITE
-------------------------------------
SECTION 1: Data Types and Literals
-----------------------------------
Test: Positive integer literal assignment, Expected: 42
Test: testInt = 42
[PASS] assertEqual: 42 == 42
Test: Negative integer literal assignment, Expected: -17
Test: testNegInt = -17
[PASS] assertEqual: -17 == -17
Test: Zero integer literal assignment, Expected: 0
Test: testZero = 0
[PASS] assertEqual: 0 == 0
Test: Positive float literal assignment, Expected: 3.14159
Test: testFloat ~= 3.14159 (float)
[PASS] assertFloatEqual: 3.142 ~= 3.142 (tol=0.000)
Test: Negative float literal assignment, Expected: -2.718
Test: testNegFloat ~= -2.718 (float)
[PASS] assertFloatEqual: -2.718 ~= -2.718 (tol=0.000)
Test: Zero float literal assignment, Expected: 0.0
Test: testFloatZero ~= 0.0 (float)
[PASS] assertFloatEqual: 0.000 ~= 0.000 (tol=0.000)
Test: String literal assignment, Expected: Hello, World!
Hello (string)Test: World!Hello, World!
[PASS] assertStringEqual: "Hello, World!" == "Hello, World!"
Test: Empty string literal assignment, Expected: (empty)
Test: testEmptyStr = '' (string)
[PASS] assertStringEqual: "" == ""
SECTION 2: Arithmetic Operators
-------------------------------
Test: Integer addition (20 + 7), Expected: 27
Test: resultAdd = 27
[PASS] assertEqual: 27 == 27
Test: Integer subtraction (20 - 7), Expected: 13
Test: resultSub = 13
[PASS] assertEqual: 13 == 13
Test: Integer multiplication (20 * 7), Expected: 140
Test: resultMul = 140
[PASS] assertEqual: 140 == 140
Test: Integer division (20 / 7), Expected: 2
Test: resultDiv = 2
[PASS] assertEqual: 2 == 2
Test: Modulo operation (20 % 7), Expected: 6
Test: resultMod = 6
[PASS] assertEqual: 6 == 6
Test: Negative operand arithmetic (-10 + 5), Expected: -5
Test: negResult = -5
[PASS] assertEqual: -5 == -5
Test: Float multiplication (10.5 * 2.5), Expected: 26.25
Test: floatResult ~= 26.25 (float)
[PASS] assertFloatEqual: 26.250 ~= 26.250 (tol=0.000)
Test: Mixed int/float addition (10 + 2.5), Expected: 12.5
Test: mixedResult ~= 12.5 (float)
[PASS] assertFloatEqual: 12.500 ~= 12.500 (tol=0.000)
SECTION 3: Comparison Operators
-------------------------------
Test: Less than (10 < 20), Expected: 1
Test: testLT = 1
[PASS] assertEqual: 1 == 1
Test: Greater than (20 > 10), Expected: 1
Test: testGT = 1
[PASS] assertEqual: 1 == 1
Test: Less than or equal (10 <= 10), Expected: 1
Test: testLE = 1
[PASS] assertEqual: 1 == 1
Test: Greater than or equal (20 >= 10), Expected: 1
Test: testGE = 1
[PASS] assertEqual: 1 == 1
Test: Equality (10 == 10), Expected: 1
Test: testEQ = 1
[PASS] assertEqual: 1 == 1
Test: Inequality (10 != 20), Expected: 1
Test: testNE = 1
[PASS] assertEqual: 1 == 1
Test: Float equality (3.14 == 3.14), Expected: 1
Test: testFloatEQ = 1
[PASS] assertEqual: 1 == 1
SECTION 4: Logical Operators
----------------------------
Test: AND operator (5 < 15 && 15 < 25), Expected: 1
Test: testAND = 1
[PASS] assertEqual: 1 == 1
Test: OR operator (5 > 100 || 15 < 20), Expected: 1
Test: testOR = 1
[PASS] assertEqual: 1 == 1
Test: Complex logical ((5 < 15 && 15 < 25) || 5 == 5), Expected: 1
Test: testComplex = 1
[PASS] assertEqual: 1 == 1
Test: Nested conditions (true && true), Expected: 1
Test: testNestedResult = 1
[PASS] assertEqual: 1 == 1
SECTION 5: Control Flow - If/Else
----------------------------------
Simple if: PASS
If-else: PASS
Grade: B (correct for 85)
Can drive: YES (correct)
SECTION 6: Control Flow - While Loops
--------------------------------------
Count up 1-5: 
1 
2 
3 
4 
5 
Count down 10-7: 
10 
9 
8 
7 
Multiplication table (3x3):
1 
2 
3 
2 
4 
6 
3 
6 
9 
Sum until > 100: 
105 (first sum > 100)
SECTION 7: Functions - Basic
----------------------------
Test: Function with no parameters greet(), Expected: 42
Test: greeting = 42
[PASS] assertEqual: 42 == 42
Test: Function square(5), Expected: 25
Test: sq5 = 25
[PASS] assertEqual: 25 == 25
Test: Function add(7, 5), Expected: 12
Test: sum12 = 12
[PASS] assertEqual: 12 == 12
Test: Function volume(3, 4, 5), Expected: 60
Test: vol = 60
[PASS] assertEqual: 60 == 60
Test: Function divide(22, 7), Expected: 3
Test: divResult = 3
[PASS] assertEqual: 3 == 3
SECTION 8: Functions - Recursion
--------------------------------
Test: fact5 = 120
[PASS] assertEqual: 120 == 120
Test: fact7 = 5040
[PASS] assertEqual: 5040 == 5040
Test: fib8 = 21
[PASS] assertEqual: 21 == 21
Test: fib10 = 55
[PASS] assertEqual: 55 == 55
Test: digitSum = 15
[PASS] assertEqual: 15 == 15
SECTION 9: Functions - Nested Calls
-----------------------------------
Test: nested1 = 30
[PASS] assertEqual: 30 == 30
Test: nested2 = 24
[PASS] assertEqual: 24 == 24
Test: nested3 = 25
[PASS] assertEqual: 25 == 25
Test: nested4 = 46
[PASS] assertEqual: 46 == 46
SECTION 10: Functions - Multiple Returns
----------------------------------------
Test: class1 = -1
[PASS] assertEqual: -1 == -1
Test: class2 = 0
[PASS] assertEqual: 0 == 0
Test: class3 = 1
[PASS] assertEqual: 1 == 1
Test: found = 17
[PASS] assertEqual: 17 == 17
SECTION 11: Built-in Functions
------------------------------
Test: absNeg = 42
[PASS] assertEqual: 42 == 42
Test: absPos = 17
[PASS] assertEqual: 17 == 17
Test: absZero = 0
[PASS] assertEqual: 0 == 0
Test: minVal = 15
[PASS] assertEqual: 15 == 15
Test: minNeg = -10
[PASS] assertEqual: -10 == -10
Test: maxVal = 23
[PASS] assertEqual: 23 == 23
Test: maxNeg = -5
[PASS] assertEqual: -5 == -5
random(100): 77 (should be 0-99)
Test: nestedBuiltin = 10
[PASS] assertEqual: 10 == 10
SECTION 12: Local Variables
---------------------------
Test: resultLocal = 42
[PASS] assertEqual: 42 == 42
Test: globalX = 100
[PASS] assertEqual: 100 == 100
Test: resultParam = 10
[PASS] assertEqual: 10 == 10
Test: globalA = 999
[PASS] assertEqual: 999 == 999
Test: multiResult = 23
[PASS] assertEqual: 23 == 23
SECTION 13: Macros
------------------
Test: area ~= 78.53975 (float)
[PASS] assertFloatEqual: 78.540 ~= 78.540 (tol=0.000)
Test: testMacro = 1
[PASS] assertEqual: 1 == 1
SECTION 14: String Operations
-----------------------------
Concatenation: Hello World
Mixed: Value = 42
SECTION 15: Edge Cases and Stress Tests
---------------------------------------
Large number: 999999
Test: deepFact = 3628800
[PASS] assertEqual: 3628800 == 3628800
Test: sixSum = 21
[PASS] assertEqual: 21 == 21
Test: complex = 23
[PASS] assertEqual: 23 == 23
Test: deepNest = 24
[PASS] assertEqual: 24 == 24
SECTION 16: Optimization Tests
------------------------------
Test: constFold1 = 15
[PASS] assertEqual: 15 == 15
Test: constFold2 = 60
[PASS] assertEqual: 60 == 60
Test: identAdd = 42
[PASS] assertEqual: 42 == 42
Test: identMul = 42
[PASS] assertEqual: 42 == 42
Test: identSub = 42
[PASS] assertEqual: 42 == 42
Test: identDiv = 42
[PASS] assertEqual: 42 == 42
Test: identZero = 0
[PASS] assertEqual: 0 == 0
SECTION 17: Real-world Algorithms
---------------------------------
Test: gcdResult = 6
[PASS] assertEqual: 6 == 6
Test: prime17 = 1
[PASS] assertEqual: 1 == 1
Test: prime18 = 0
[PASS] assertEqual: 0 == 0
Test: pow2_10 = 1024
[PASS] assertEqual: 1024 == 1024
Test: pow3_4 = 81
[PASS] assertEqual: 81 == 81
SECTION 18: Type System and Automatic Conversion
------------------------------------------------
Int var: 42 (expected: 42)
Float var: 3.142 (expected: 3.14159)
String var: Hello (expected: Hello)
Test: sqInt = 25
[PASS] assertEqual: 25 == 25
Test: sqFloat ~= 6.25 (float)
[PASS] assertFloatEqual: 6.250 ~= 6.250 (tol=0.000)
Test: sqConverted = 9
[PASS] assertEqual: 9 == 9
Test: sqFloatConverted ~= 16.0 (float)
[PASS] assertFloatEqual: 16.000 ~= 16.000 (tol=0.000)
Test: assignFloat ~= 42.0 (float)
[PASS] assertFloatEqual: 42.000 ~= 42.000 (tol=0.000)
Test: assignIntVal = 9
[PASS] assertEqual: 9 == 9
Test: floatFromInt ~= 100.0 (float)
[PASS] assertFloatEqual: 100.000 ~= 100.000 (tol=0.000)
Test: intFromFloat = 2
[PASS] assertEqual: 2 == 2
Test: piAsInt = 3
[PASS] assertEqual: 3 == 3
Test: intAsFloat ~= 42.0 (float)
[PASS] assertFloatEqual: 42.000 ~= 42.000 (tol=0.000)
Test: chainResult ~= 8.0 (float)
[PASS] assertFloatEqual: 8.000 ~= 8.000 (tol=0.000)
Test: nestedConv = 15
[PASS] assertEqual: 15 == 15
SECTION 19: Ternary Operator
----------------------------
Test: ternary1 = 100
[PASS] assertEqual: 100 == 100
Test: ternary2 = 200
[PASS] assertEqual: 200 == 200
Test: ternMax = 20
[PASS] assertEqual: 20 == 20
Test: ternMin = 15
[PASS] assertEqual: 15 == 15
Test: nestedTern = 111
[PASS] assertEqual: 111 == 111
Test: ternExpr = 60
[PASS] assertEqual: 60 == 60
Test: ternZero = 999
[PASS] assertEqual: 999 == 999
Test: macroMax1 = 42
[PASS] assertEqual: 42 == 42
Test: macroMax2 = -5
[PASS] assertEqual: -5 == -5
Test: macroMin1 = 17
[PASS] assertEqual: 17 == 17
Test: floatTern1 ~= 5.5 (float)
[PASS] assertFloatEqual: 5.500 ~= 5.500 (tol=0.000)
Test: ternFunc = 20
[PASS] assertEqual: 20 == 20
Test: complexCond = 12
[PASS] assertEqual: 12 == 12
SECTION 20: Logical NOT Operator
--------------------------------
Test: notTrue = 1
[PASS] assertEqual: 1 == 1
Test: notFalse = 0
[PASS] assertEqual: 0 == 0
Test: notZero = 1
[PASS] assertEqual: 1 == 1
Test: notNonZero = 0
[PASS] assertEqual: 0 == 0
Test: notEqual = 0
[PASS] assertEqual: 0 == 0
Test: doubleNot = 1
[PASS] assertEqual: 1 == 1
Test: testNotComplex = 1
[PASS] assertEqual: 1 == 1
Test: testNotIneq = 1
[PASS] assertEqual: 1 == 1

========================================
  COMPREHENSIVE TEST SUITE COMPLETE
========================================

Note: Built-in assertions automatically report failures.
If you see this message, all tests passed!



--------------------------------------------------------------------------------
FILE: 02 comprehensive test2.lj
TYPE: SOURCE
--------------------------------------------------------------------------------
>>> SOURCE FILE MODIFIED
Previous hash: a0d475cfc98c8fe500dd49446f7f5ed2
Current hash:  a450599500e4f6f3e0312fb824f471cc

--- PREVIOUS OUTPUT ---
=== SECTION 1: Integer Arithmetic ===
[ 1 ] -- PASS: 5+3=8
[ 2 ] -- PASS: 10-4=6
[ 3 ] -- PASS: 7*6=42
[ 4 ] -- PASS: 20/4=5
[ 5 ] -- PASS: 17%5=2
[ 6 ] -- PASS: negation=-10

=== SECTION 2: Operator Precedence ===
[ 7 ] -- PASS: 2+3*4=14
[ 8 ] -- PASS: (2+3)*4=20
[ 9 ] -- PASS: 100/10/2=5
[ 10 ] -- PASS: 2+3*4-5=9

=== SECTION 3: Comparison Operators ===
[ 11 ] -- PASS: 5==5 is true
[ 12 ] -- PASS: 5==6 is false
[ 13 ] -- PASS: 5!=6 is true
[ 14 ] -- PASS: 5<10 is true
[ 15 ] -- PASS: 10>5 is true
[ 16 ] -- PASS: 5<=5 is true
[ 17 ] -- PASS: 5>=5 is true

=== SECTION 4: Logical Operators ===
[ 18 ] -- PASS: 1&&1=1
[ 19 ] -- PASS: 1&&0=0
[ 20 ] -- PASS: 0||1=1
[ 21 ] -- PASS: 0||0=0
[ 22 ] -- PASS: !0=1
[ 23 ] -- PASS: !1=0

=== SECTION 5: Bitwise Operators ===
[ 24 ] -- PASS: 5&&3=1
[ 25 ] -- PASS: 5|3=7
[ 26 ] -- PASS: 5^3=6

=== SECTION 6: Float Arithmetic ===
[ 27 ] -- PASS: 3.5+2.5=6.0
[ 28 ] -- PASS: 10.0-4.5=5.5
[ 29 ] -- PASS: 2.5*4.0=10.0
[ 30 ] -- PASS: 15.0/3.0=5.0

=== SECTION 7: Increment/Decrement ===
[ 31 ] -- PASS: x++=6
[ 32 ] -- PASS: x--=4
[ 33 ] -- PASS: ++x pre-increment
[ 34 ] -- PASS: --x pre-decrement

=== SECTION 8: Compound Assignment ===
[ 35 ] -- PASS: x+=5 -> 15
[ 36 ] -- PASS: x-=3 -> 7
[ 37 ] -- PASS: x*=2 -> 20
[ 38 ] -- PASS: x/=4 -> 5
[ 39 ] -- PASS: x%=5 -> 2

=== SECTION 9: While Loop ===
[ 40 ] -- PASS: sum 1-5=15
[ 41 ] -- PASS: countdown count=5

=== SECTION 10: If/Else ===
[ 42 ] -- PASS: if x>5 true branch
[ 43 ] -- PASS: if x>5 false branch
[ 44 ] -- PASS: else-if chain

=== SECTION 11: Ternary Operator ===
[ 45 ] -- PASS: ternary true=100
[ 46 ] -- PASS: ternary false=200

=== SECTION 12: Functions ===
[ 47 ] -- PASS: add(3,4)=7
[ 48 ] -- PASS: multiply(6,7)=42
[ 49 ] -- PASS: factorial(5)=120
(fibonacci test skipped - heavy recursion)

=== SECTION 13: Arrays ===
[ 50 ] -- PASS: arr[0]=10
[ 51 ] -- PASS: arr[4]=50
[ 52 ] -- PASS: array sum=150
[ 53 ] -- PASS: arr[2]=arr[0]+arr[1]=30

=== SECTION 14: Pointers ===
[ 54 ] -- PASS: *ptr=42
[ 55 ] -- PASS: *ptr=100 changes val
[ 56 ] -- PASS: ptr to array[0]=10

=== SECTION 15: Built-ins ===
[ 57 ] -- PASS: abs(-42)=42
[ 58 ] -- PASS: min(10,5)=5
[ 59 ] -- PASS: max(10,5)=10
[ 60 ] -- PASS: sqrt(16)=4
[ 61 ] -- PASS: pow(2,8)=256

=== SECTION 16: Strings ===
[ 62 ] -- PASS: string concat
[ 63 ] -- PASS: len('Hello')=5

=== SECTION 17: Type Conversions ===
[ 64 ] -- PASS: (int)3.7=3
[ 65 ] -- PASS: (float)42=42.0

=== SECTION 18: Local Variables ===
[ 66 ] -- PASS: local+param+global=160
[ 67 ] -- PASS: global unchanged=100

=== SECTION 19: Nested Calls ===
[ 68 ] -- PASS: double(triple(5))=30
[ 69 ] -- PASS: add(double(3),triple(4))=18

=== SECTION 20: Complex Expressions ===
[ 70 ] -- PASS: complex expr=19
[ 71 ] -- PASS: chained comparison=true

=== SECTION 21: Function Pointers (SKIPPED) ===

==========================================
           TEST SUMMARY
==========================================
Total tests:71
Passed:71
Failed:0

*** ALL TESTS PASSED ***
==========================================


+++ CURRENT OUTPUT +++
=== SECTION 1: Integer Arithmetic ===
[ 1 ] -- PASS: 5+3=8
[ 2 ] -- PASS: 10-4=6
[ 3 ] -- PASS: 7*6=42
[ 4 ] -- PASS: 20/4=5
[ 5 ] -- PASS: 17%5=2
[ 6 ] -- PASS: negation=-10

=== SECTION 2: Operator Precedence ===
[ 7 ] -- PASS: 2+3*4=14
[ 8 ] -- PASS: (2+3)*4=20
[ 9 ] -- PASS: 100/10/2=5
[ 10 ] -- PASS: 2+3*4-5=9

=== SECTION 3: Comparison Operators ===
[ 11 ] -- PASS: 5==5 is true
[ 12 ] -- PASS: 5==6 is false
[ 13 ] -- PASS: 5!=6 is true
[ 14 ] -- PASS: 5<10 is true
[ 15 ] -- PASS: 10>5 is true
[ 16 ] -- PASS: 5<=5 is true
[ 17 ] -- PASS: 5>=5 is true

=== SECTION 4: Logical Operators ===
[ 18 ] -- PASS: 1&&1=1
[ 19 ] -- PASS: 1&&0=0
[ 20 ] -- PASS: 0||1=1
[ 21 ] -- PASS: 0||0=0
[ 22 ] -- PASS: !0=1
[ 23 ] -- PASS: !1=0

=== SECTION 5: Bitwise Operators ===
[ 24 ] -- PASS: 5&&3=1
[ 25 ] -- PASS: 5|3=7
[ 26 ] -- PASS: 5^3=6

=== SECTION 6: Float Arithmetic ===
[ 27 ] -- PASS: 3.5+2.5=6.0
[ 28 ] -- PASS: 10.0-4.5=5.5
[ 29 ] -- PASS: 2.5*4.0=10.0
[ 30 ] -- PASS: 15.0/3.0=5.0

=== SECTION 7: Increment/Decrement ===
[ 31 ] -- PASS: x++=6
[ 32 ] -- PASS: x--=4
[ 33 ] -- PASS: ++x pre-increment
[ 34 ] -- PASS: --x pre-decrement

=== SECTION 8: Compound Assignment ===
[ 35 ] -- PASS: x+=5 -> 15
[ 36 ] -- PASS: x-=3 -> 7
[ 37 ] -- PASS: x*=2 -> 20
[ 38 ] -- PASS: x/=4 -> 5
[ 39 ] -- PASS: x%=5 -> 2

=== SECTION 9: While Loop ===
[ 40 ] -- PASS: sum 1-5=15
[ 41 ] -- PASS: countdown count=5

=== SECTION 10: If/Else ===
[ 42 ] -- PASS: if x>5 true branch
[ 43 ] -- PASS: if x>5 false branch
[ 44 ] -- PASS: else-if chain

=== SECTION 11: Ternary Operator ===
[ 45 ] -- PASS: ternary true=100
[ 46 ] -- PASS: ternary false=200

=== SECTION 12: Functions ===
[ 47 ] -- PASS: add(3,4)=7
[ 48 ] -- PASS: multiply(6,7)=42
[ 49 ] -- PASS: factorial(5)=120
(fibonacci test skipped - heavy recursion)

=== SECTION 13: Arrays ===
[ 50 ] -- PASS: nums[0]=10
[ 51 ] -- PASS: nums[4]=50
[ 52 ] -- PASS: array sum=150
[ 53 ] -- PASS: nums[2]=nums[0]+nums[1]=30

=== SECTION 14: Pointers ===
[ 54 ] -- PASS: *ptr=42
[ 55 ] -- PASS: *ptr=100 changes val
[ 56 ] -- PASS: ptr to array[0]=10

=== SECTION 15: Built-ins ===
[ 57 ] -- PASS: abs(-42)=42
[ 58 ] -- PASS: min(10,5)=5
[ 59 ] -- PASS: max(10,5)=10
[ 60 ] -- PASS: sqrt(16)=4
[ 61 ] -- PASS: pow(2,8)=256

=== SECTION 16: Strings ===
[ 62 ] -- PASS: string concat
[ 63 ] -- PASS: len('Hello')=5

=== SECTION 17: Type Conversions ===
[ 64 ] -- PASS: (int)3.7=3
[ 65 ] -- PASS: (float)42=42.0

=== SECTION 18: Local Variables ===
[ 66 ] -- PASS: local+param+global=160
[ 67 ] -- PASS: global unchanged=100

=== SECTION 19: Nested Calls ===
[ 68 ] -- PASS: double(triple(5))=30
[ 69 ] -- PASS: add(double(3),triple(4))=18

=== SECTION 20: Complex Expressions ===
[ 70 ] -- PASS: complex expr=19
[ 71 ] -- PASS: chained comparison=true

=== SECTION 21: Function Pointers (SKIPPED) ===

==========================================
           TEST SUMMARY
==========================================
Total tests:71
Passed:71
Failed:0

*** ALL TESTS PASSED ***
==========================================


--------------------------------------------------------------------------------
FILE: 15 game 24-b.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
=== Game 24 Solver (-b version) ===

Digits: 8, 3, 7, 3

Finding all ways to make 24...

  (8 + (3 * 3)) + 7 = 24
  8 + ((3 * 3) + 7) = 24
  (8 + 7) + (3 * 3) = 24
  8 + (7 + (3 * 3)) = 24
  (8 + 7) + (3 * 3) = 24
  8 + (7 + (3 * 3)) = 24
  (8 + (3 * 3)) + 7 = 24
  8 + ((3 * 3) + 7) = 24
  ((3 * 3) + 8) + 7 = 24
  (3 * 3) + (8 + 7) = 24
  ((3 * 3) + 7) + 8 = 24
  (3 * 3) + (7 + 8) = 24
  (7 + 8) + (3 * 3) = 24
  7 + (8 + (3 * 3)) = 24
  (7 + 8) + (3 * 3) = 24
  7 + (8 + (3 * 3)) = 24
  (7 + (3 * 3)) + 8 = 24
  7 + ((3 * 3) + 8) = 24
  (7 + (3 * 3)) + 8 = 24
  7 + ((3 * 3) + 8) = 24
  ((3 * 3) + 8) + 7 = 24
  (3 * 3) + (8 + 7) = 24
  ((3 * 3) + 7) + 8 = 24
  (3 * 3) + (7 + 8) = 24

Total solutions found: 24 (includes duplicates)

=== Game 24 Complete ===


+++ CURRENT OUTPUT +++
=== Game 24 Solver (-b version) ===

Digits: 6, 2, 1, 5

Finding all ways to make 24...

  (6 - 2) * (1 + 5) = 24
  (6 - 2) * (5 + 1) = 24
  6 * ((1 - 2) + 5) = 24
  6 * (1 - (2 - 5)) = 24
  ((6 + 1) + 5) * 2 = 24
  (6 + (1 + 5)) * 2 = 24
  6 * ((1 + 5) - 2) = 24
  6 * (1 + (5 - 2)) = 24
  6 * ((5 - 2) + 1) = 24
  6 * (5 - (2 - 1)) = 24
  ((6 + 5) + 1) * 2 = 24
  (6 + (5 + 1)) * 2 = 24
  6 * ((5 + 1) - 2) = 24
  6 * (5 + (1 - 2)) = 24
  2 * ((6 + 1) + 5) = 24
  2 * (6 + (1 + 5)) = 24
  2 * ((6 + 5) + 1) = 24
  2 * (6 + (5 + 1)) = 24
  2 * ((1 + 6) + 5) = 24
  2 * (1 + (6 + 5)) = 24
  2 * ((1 + 5) + 6) = 24
  2 * (1 + (5 + 6)) = 24
  2 * ((5 + 6) + 1) = 24
  2 * (5 + (6 + 1)) = 24
  2 * ((5 + 1) + 6) = 24
  2 * (5 + (1 + 6)) = 24
  ((1 + 6) + 5) * 2 = 24
  (1 + (6 + 5)) * 2 = 24
  ((1 - 2) + 5) * 6 = 24
  (1 - (2 - 5)) * 6 = 24
  ((1 + 5) + 6) * 2 = 24
  (1 + (5 + 6)) * 2 = 24
  (1 + 5) * (6 - 2) = 24
  ((1 + 5) - 2) * 6 = 24
  (1 + (5 - 2)) * 6 = 24
  ((5 + 6) + 1) * 2 = 24
  (5 + (6 + 1)) * 2 = 24
  ((5 - 2) + 1) * 6 = 24
  (5 - (2 - 1)) * 6 = 24
  ((5 + 1) + 6) * 2 = 24
  (5 + (1 + 6)) * 2 = 24
  (5 + 1) * (6 - 2) = 24
  ((5 + 1) - 2) * 6 = 24
  (5 + (1 - 2)) * 6 = 24

Total solutions found: 44 (includes duplicates)

=== Game 24 Complete ===


--------------------------------------------------------------------------------
FILE: 15 game 24.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
=== Game 24 Solver ===

Digits: 6, 7, 6, 9

Finding all ways to make 24...

  6 * ((7 + 6) - 9) = 24
  6 * (7 + (6 - 9)) = 24
  ((6 + 7) - 9) * 6 = 24
  (6 + (7 - 9)) * 6 = 24
  6 * ((7 - 9) + 6) = 24
  6 * (7 - (9 - 6)) = 24
  6 * ((6 + 7) - 9) = 24
  6 * (6 + (7 - 9)) = 24
  (6 + 6) * (9 - 7) = 24
  6 * ((6 - 9) + 7) = 24
  6 * (6 - (9 - 7)) = 24
  ((6 - 9) + 7) * 6 = 24
  (6 - (9 - 7)) * 6 = 24
  ((7 + 6) - 9) * 6 = 24
  (7 + (6 - 9)) * 6 = 24
  ((7 + 6) - 9) * 6 = 24
  (7 + (6 - 9)) * 6 = 24
  ((7 - 9) + 6) * 6 = 24
  (7 - (9 - 6)) * 6 = 24
  ((7 - 9) + 6) * 6 = 24
  (7 - (9 - 6)) * 6 = 24
  6 * ((6 + 7) - 9) = 24
  6 * (6 + (7 - 9)) = 24
  (6 + 6) * (9 - 7) = 24
  6 * ((6 - 9) + 7) = 24
  6 * (6 - (9 - 7)) = 24
  6 * ((7 + 6) - 9) = 24
  6 * (7 + (6 - 9)) = 24
  ((6 + 7) - 9) * 6 = 24
  (6 + (7 - 9)) * 6 = 24
  6 * ((7 - 9) + 6) = 24
  6 * (7 - (9 - 6)) = 24
  ((6 - 9) + 7) * 6 = 24
  (6 - (9 - 7)) * 6 = 24
  (9 - 7) * (6 + 6) = 24
  (9 - 7) * (6 + 6) = 24

Total solutions found: 36 (includes duplicates)

=== Game 24 Complete ===


+++ CURRENT OUTPUT +++
=== Game 24 Solver ===

Digits: 6, 5, 7, 5

Finding all ways to make 24...

  (6 + (5 * 5)) - 7 = 24
  6 + ((5 * 5) - 7) = 24
  (6 - 7) + (5 * 5) = 24
  6 - (7 - (5 * 5)) = 24
  (6 - 7) + (5 * 5) = 24
  6 - (7 - (5 * 5)) = 24
  (6 + (5 * 5)) - 7 = 24
  6 + ((5 * 5) - 7) = 24
  (5 * 7) - (6 + 5) = 24
  ((5 * 7) - 6) - 5 = 24
  (5 * 7) - (5 + 6) = 24
  ((5 * 7) - 5) - 6 = 24
  ((5 * 5) + 6) - 7 = 24
  (5 * 5) + (6 - 7) = 24
  ((5 * 5) - 7) + 6 = 24
  (5 * 5) - (7 - 6) = 24
  (7 * 5) - (6 + 5) = 24
  ((7 * 5) - 6) - 5 = 24
  (7 * 5) - (5 + 6) = 24
  ((7 * 5) - 5) - 6 = 24
  (7 * 5) - (6 + 5) = 24
  ((7 * 5) - 6) - 5 = 24
  (7 * 5) - (5 + 6) = 24
  ((7 * 5) - 5) - 6 = 24
  ((5 * 5) + 6) - 7 = 24
  (5 * 5) + (6 - 7) = 24
  ((5 * 5) - 7) + 6 = 24
  (5 * 5) - (7 - 6) = 24
  (5 * 7) - (6 + 5) = 24
  ((5 * 7) - 6) - 5 = 24
  (5 * 7) - (5 + 6) = 24
  ((5 * 7) - 5) - 6 = 24

Total solutions found: 32 (includes duplicates)

=== Game 24 Complete ===


--------------------------------------------------------------------------------
FILE: 18 test array resize.lj
TYPE: SOURCE
--------------------------------------------------------------------------------
>>> SOURCE FILE MODIFIED
Previous hash: 76ac5212076e2ee621b62fc9ff831e77
Current hash:  b856c6782b684bbd967826b67a293912

--- PREVIOUS OUTPUT ---
=== ARRAY RESIZE TEST (V1.022.64) ===

TEST 1: Create and populate small array
---------------------------------------
  arr[0] = 100 (expected 100)
  arr[1] = 200 (expected 200)
  arr[2] = 300 (expected 300)
[PASS] assertEqual: 100 == 100
[PASS] assertEqual: 200 == 200
[PASS] assertEqual: 300 == 300
  Initial array works!

TEST 2: Resize array from 3 to 6
--------------------------------
  Array resized to 6 elements
  arr[0] = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  arr[1] = 200 (expected 200)
[PASS] assertEqual: 200 == 200
  arr[2] = 300 (expected 300)
[PASS] assertEqual: 300 == 300
  Original elements preserved!
  Setting arr[3] = 400...
  arr[3] = 400 (expected 400)
[PASS] assertEqual: 400 == 400
  Setting arr[5] = 600...
  arr[5] = 600 (expected 600)
[PASS] assertEqual: 600 == 600

=== ARRAY RESIZE TEST PASSED ===


+++ CURRENT OUTPUT +++
=== ARRAY RESIZE TEST (V1.022.64) ===

TEST 1: Create and populate small array
---------------------------------------
  data[0] = 100 (expected 100)
  data[1] = 200 (expected 200)
  data[2] = 300 (expected 300)
[PASS] assertEqual: 100 == 100
[PASS] assertEqual: 200 == 200
[PASS] assertEqual: 300 == 300
  Initial array works!

TEST 2: Resize array from 3 to 6
--------------------------------
  Array resized to 6 elements
  data[0] = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  data[1] = 200 (expected 200)
[PASS] assertEqual: 200 == 200
  data[2] = 300 (expected 300)
[PASS] assertEqual: 300 == 300
  Original elements preserved!
  Setting data[3] = 400...
  data[3] = 400 (expected 400)
[PASS] assertEqual: 400 == 400
  Setting data[5] = 600...
  data[5] = 600 (expected 600)
[PASS] assertEqual: 600 == 600

=== ARRAY RESIZE TEST PASSED ===


--------------------------------------------------------------------------------
FILE: 20 array sort stress test-b.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
=================================
Array Sort Stress Test (-b)
50000 float elements - Quicksort
=================================

Filling array with 50000 random values...
Array filled.

Before sort - first 10 elements:
  data[0] = 164.717
  data[1] = 136.228
  data[2] = 437.240
  data[9] = 750.186

Sorting array using quicksort...
Sort complete!

After sort - first 10 elements:
  data[0] = 0.016
  data[1] = 0.021
  data[2] = 0.024
  data[9] = 0.085

Every 100th element (should be ascending):
=================================
  data[0] = 0.016
  data[100] = 0.580
  data[200] = 1.215
  data[300] = 1.843
  data[400] = 2.502
  data[500] = 3.031
  data[600] = 3.655
  data[700] = 4.212
  data[800] = 4.841
  data[900] = 5.519
  data[1000] = 6.222
  data[1100] = 6.908
  data[1200] = 7.537
  data[1300] = 8.242
  data[1400] = 8.823
  data[1500] = 9.441
  data[1600] = 10.107
  data[1700] = 10.742
  data[1800] = 11.435
  data[1900] = 11.987
  data[2000] = 12.627
  data[2100] = 13.286
  data[2200] = 13.945
  data[2300] = 14.511
  data[2400] = 15.053
  data[2500] = 15.673
  data[2600] = 16.270
  data[2700] = 16.890
  data[2800] = 17.504
  data[2900] = 18.175
  data[3000] = 18.688
  data[3100] = 19.281
  data[3200] = 19.914
  data[3300] = 20.657
  data[3400] = 21.158
  data[3500] = 21.828
  data[3600] = 22.472
  data[3700] = 23.248
  data[3800] = 23.892
  data[3900] = 24.518
  data[4000] = 25.182
  data[4100] = 25.792
  data[4200] = 26.448
  data[4300] = 27.065
  data[4400] = 27.787
  data[4500] = 28.377
  data[4600] = 29.011
  data[4700] = 29.502
  data[4800] = 30.094
  data[4900] = 30.731
  data[5000] = 31.245
  data[5100] = 31.987
  data[5200] = 32.633
  data[5300] = 33.331
  data[5400] = 33.977
  data[5500] = 34.587
  data[5600] = 35.189
  data[5700] = 35.929
  data[5800] = 36.459
  data[5900] = 37.070
  data[6000] = 37.670
  data[6100] = 38.238
  data[6200] = 38.888
  data[6300] = 39.478
  data[6400] = 40.115
  data[6500] = 40.746
  data[6600] = 41.423
  data[6700] = 42.096
  data[6800] = 42.756
  data[6900] = 43.370
  data[7000] = 44.061
  data[7100] = 44.679
  data[7200] = 45.287
  data[7300] = 45.882
  data[7400] = 46.436
  data[7500] = 47.107
  data[7600] = 47.582
  data[7700] = 48.237
  data[7800] = 48.791
  data[7900] = 49.516
  data[8000] = 50.079
  data[8100] = 50.704
  data[8200] = 51.372
  data[8300] = 51.970
  data[8400] = 52.612
  data[8500] = 53.138
  data[8600] = 53.809
  data[8700] = 54.412
  data[8800] = 54.999
  data[8900] = 55.599
  data[9000] = 56.244
  data[9100] = 56.806
  data[9200] = 57.361
  data[9300] = 58.000
  data[9400] = 58.659
  data[9500] = 59.262
  data[9600] = 59.888
  data[9700] = 60.511
  data[9800] = 61.224
  data[9900] = 61.841
  data[10000] = 62.500
  data[10100] = 63.062
  data[10200] = 63.621
  data[10300] = 64.273
  data[10400] = 64.890
  data[10500] = 65.588
  data[10600] = 66.154
  data[10700] = 66.718
  data[10800] = 67.380
  data[10900] = 67.876
  data[11000] = 68.550
  data[11100] = 69.120
  data[11200] = 69.724
  data[11300] = 70.393
  data[11400] = 71.034
  data[11500] = 71.597
  data[11600] = 72.129
  data[11700] = 72.706
  data[11800] = 73.301
  data[11900] = 73.930
  data[12000] = 74.651
  data[12100] = 75.191
  data[12200] = 75.755
  data[12300] = 76.333
  data[12400] = 77.063
  data[12500] = 77.657
  data[12600] = 78.290
  data[12700] = 78.886
  data[12800] = 79.433
  data[12900] = 80.020
  data[13000] = 80.710
  data[13100] = 81.247
  data[13200] = 81.846
  data[13300] = 82.493
  data[13400] = 83.062
  data[13500] = 83.730
  data[13600] = 84.300
  data[13700] = 84.998
  data[13800] = 85.525
  data[13900] = 86.127
  data[14000] = 86.694
  data[14100] = 87.398
  data[14200] = 88.019
  data[14300] = 88.814
  data[14400] = 89.499
  data[14500] = 90.126
  data[14600] = 90.813
  data[14700] = 91.462
  data[14800] = 92.085
  data[14900] = 92.751
  data[15000] = 93.405
  data[15100] = 93.955
  data[15200] = 94.561
  data[15300] = 95.135
  data[15400] = 95.887
  data[15500] = 96.579
  data[15600] = 97.091
  data[15700] = 97.772
  data[15800] = 98.349
  data[15900] = 98.998
  data[16000] = 99.648
  data[16100] = 100.334
  data[16200] = 101.103
  data[16300] = 101.682
  data[16400] = 102.317
  data[16500] = 103.041
  data[16600] = 103.688
  data[16700] = 104.348
  data[16800] = 105.016
  data[16900] = 105.528
  data[17000] = 106.261
  data[17100] = 106.847
  data[17200] = 107.454
  data[17300] = 108.103
  data[17400] = 108.763
  data[17500] = 109.312
  data[17600] = 109.886
  data[17700] = 110.546
  data[17800] = 111.102
  data[17900] = 111.733
  data[18000] = 112.391
  data[18100] = 112.984
  data[18200] = 113.638
  data[18300] = 114.261
  data[18400] = 114.863
  data[18500] = 115.432
  data[18600] = 116.145
  data[18700] = 116.721
  data[18800] = 117.390
  data[18900] = 118.045
  data[19000] = 118.671
  data[19100] = 119.278
  data[19200] = 119.877
  data[19300] = 120.490
  data[19400] = 121.155
  data[19500] = 121.807
  data[19600] = 122.387
  data[19700] = 122.903
  data[19800] = 123.498
  data[19900] = 124.111
  data[20000] = 124.700
  data[20100] = 125.359
  data[20200] = 125.985
  data[20300] = 126.585
  data[20400] = 127.345
  data[20500] = 127.955
  data[20600] = 128.673
  data[20700] = 129.260
  data[20800] = 129.897
  data[20900] = 130.516
  data[21000] = 131.225
  data[21100] = 131.898
  data[21200] = 132.527
  data[21300] = 133.048
  data[21400] = 133.635
  data[21500] = 134.255
  data[21600] = 134.918
  data[21700] = 135.584
  data[21800] = 136.239
  data[21900] = 136.837
  data[22000] = 137.345
  data[22100] = 137.908
  data[22200] = 138.491
  data[22300] = 139.105
  data[22400] = 139.726
  data[22500] = 140.421
  data[22600] = 140.951
  data[22700] = 141.532
  data[22800] = 142.076
  data[22900] = 142.648
  data[23000] = 143.251
  data[23100] = 143.920
  data[23200] = 144.550
  data[23300] = 145.195
  data[23400] = 145.832
  data[23500] = 146.454
  data[23600] = 147.116
  data[23700] = 147.701
  data[23800] = 148.322
  data[23900] = 148.851
  data[24000] = 149.486
  data[24100] = 150.182
  data[24200] = 150.754
  data[24300] = 151.365
  data[24400] = 151.960
  data[24500] = 152.497
  data[24600] = 153.152
  data[24700] = 153.806
  data[24800] = 154.489
  data[24900] = 155.188
  data[25000] = 155.972
  data[25100] = 156.498
  data[25200] = 157.169
  data[25300] = 157.773
  data[25400] = 158.386
  data[25500] = 159.056
  data[25600] = 159.755
  data[25700] = 160.409
  data[25800] = 161.232
  data[25900] = 161.928
  data[26000] = 162.526
  data[26100] = 163.215
  data[26200] = 163.738
  data[26300] = 164.304
  data[26400] = 164.933
  data[26500] = 165.555
  data[26600] = 166.311
  data[26700] = 166.966
  data[26800] = 167.631
  data[26900] = 168.372
  data[27000] = 169.154
  data[27100] = 169.845
  data[27200] = 170.545
  data[27300] = 171.256
  data[27400] = 172.131
  data[27500] = 172.887
  data[27600] = 173.682
  data[27700] = 174.596
  data[27800] = 175.382
  data[27900] = 176.276
  data[28000] = 176.974
  data[28100] = 177.639
  data[28200] = 178.493
  data[28300] = 179.253
  data[28400] = 180.035
  data[28500] = 180.857
  data[28600] = 181.551
  data[28700] = 182.280
  data[28800] = 183.239
  data[28900] = 184.082
  data[29000] = 184.918
  data[29100] = 185.936
  data[29200] = 186.857
  data[29300] = 187.826
  data[29400] = 188.931
  data[29500] = 189.898
  data[29600] = 190.810
  data[29700] = 191.701
  data[29800] = 192.601
  data[29900] = 193.539
  data[30000] = 194.465
  data[30100] = 195.601
  data[30200] = 196.464
  data[30300] = 197.524
  data[30400] = 198.416
  data[30500] = 199.424
  data[30600] = 200.519
  data[30700] = 201.542
  data[30800] = 202.659
  data[30900] = 203.830
  data[31000] = 204.798
  data[31100] = 205.959
  data[31200] = 206.992
  data[31300] = 208.093
  data[31400] = 209.162
  data[31500] = 210.314
  data[31600] = 211.600
  data[31700] = 212.591
  data[31800] = 213.944
  data[31900] = 215.076
  data[32000] = 216.390
  data[32100] = 217.700
  data[32200] = 219.054
  data[32300] = 220.161
  data[32400] = 221.364
  data[32500] = 222.728
  data[32600] = 223.944
  data[32700] = 225.406
  data[32800] = 226.480
  data[32900] = 227.586
  data[33000] = 228.908
  data[33100] = 230.378
  data[33200] = 231.698
  data[33300] = 232.875
  data[33400] = 234.086
  data[33500] = 235.743
  data[33600] = 237.000
  data[33700] = 238.562
  data[33800] = 240.251
  data[33900] = 241.804
  data[34000] = 243.290
  data[34100] = 244.593
  data[34200] = 246.119
  data[34300] = 248.045
  data[34400] = 249.468
  data[34500] = 251.130
  data[34600] = 252.796
  data[34700] = 254.560
  data[34800] = 256.010
  data[34900] = 257.701
  data[35000] = 259.564
  data[35100] = 261.442
  data[35200] = 263.208
  data[35300] = 264.647
  data[35400] = 266.109
  data[35500] = 268.333
  data[35600] = 270.227
  data[35700] = 272.249
  data[35800] = 274.001
  data[35900] = 275.940
  data[36000] = 277.605
  data[36100] = 279.661
  data[36200] = 281.640
  data[36300] = 283.361
  data[36400] = 285.656
  data[36500] = 288.107
  data[36600] = 290.018
  data[36700] = 291.714
  data[36800] = 294.096
  data[36900] = 296.401
  data[37000] = 298.773
  data[37100] = 301.555
  data[37200] = 304.214
  data[37300] = 306.740
  data[37400] = 309.233
  data[37500] = 311.963
  data[37600] = 314.354
  data[37700] = 316.909
  data[37800] = 319.374
  data[37900] = 322.025
  data[38000] = 324.972
  data[38100] = 328.063
  data[38200] = 331.060
  data[38300] = 334.347
  data[38400] = 337.200
  data[38500] = 340.168
  data[38600] = 343.049
  data[38700] = 346.089
  data[38800] = 349.056
  data[38900] = 352.114
  data[39000] = 354.989
  data[39100] = 357.885
  data[39200] = 360.814
  data[39300] = 363.987
  data[39400] = 367.735
  data[39500] = 371.564
  data[39600] = 375.440
  data[39700] = 379.177
  data[39800] = 382.589
  data[39900] = 385.584
  data[40000] = 388.586
  data[40100] = 391.964
  data[40200] = 395.762
  data[40300] = 399.772
  data[40400] = 404.094
  data[40500] = 408.315
  data[40600] = 412.639
  data[40700] = 417.074
  data[40800] = 421.352
  data[40900] = 425.905
  data[41000] = 430.661
  data[41100] = 436.246
  data[41200] = 441.423
  data[41300] = 448.313
  data[41400] = 453.889
  data[41500] = 458.703
  data[41600] = 464.200
  data[41700] = 469.670
  data[41800] = 475.937
  data[41900] = 482.183
  data[42000] = 488.683
  data[42100] = 496.477
  data[42200] = 502.456
  data[42300] = 510.324
  data[42400] = 517.113
  data[42500] = 524.303
  data[42600] = 530.872
  data[42700] = 538.808
  data[42800] = 547.712
  data[42900] = 555.771
  data[43000] = 562.587
  data[43100] = 570.231
  data[43200] = 577.764
  data[43300] = 586.990
  data[43400] = 595.639
  data[43500] = 604.035
  data[43600] = 612.607
  data[43700] = 621.556
  data[43800] = 630.440
  data[43900] = 639.616
  data[44000] = 649.695
  data[44100] = 660.461
  data[44200] = 670.147
  data[44300] = 679.906
  data[44400] = 690.899
  data[44500] = 702.376
  data[44600] = 714.851
  data[44700] = 727.572
  data[44800] = 742.625
  data[44900] = 755.362
  data[45000] = 773.452
  data[45100] = 789.715
  data[45200] = 805.614
  data[45300] = 825.968
  data[45400] = 842.894
  data[45500] = 862.023
  data[45600] = 878.777
  data[45700] = 897.531
  data[45800] = 917.708
  data[45900] = 939.202
  data[46000] = 960.692
  data[46100] = 980.757
  data[46200] = 1005.553
  data[46300] = 1036.236
  data[46400] = 1062.291
  data[46500] = 1091.454
  data[46600] = 1118.500
  data[46700] = 1153.167
  data[46800] = 1187.235
  data[46900] = 1227.062
  data[47000] = 1268.109
  data[47100] = 1309.460
  data[47200] = 1357.026
  data[47300] = 1406.745
  data[47400] = 1449.895
  data[47500] = 1500.139
  data[47600] = 1560.453
  data[47700] = 1621.193
  data[47800] = 1699.019
  data[47900] = 1781.905
  data[48000] = 1869.017
  data[48100] = 1974.586
  data[48200] = 2065.520
  data[48300] = 2173.853
  data[48400] = 2301.874
  data[48500] = 2448.346
  data[48600] = 2593.603
  data[48700] = 2781.014
  data[48800] = 2965.987
  data[48900] = 3157.761
  data[49000] = 3472.356
  data[49100] = 3862.078
  data[49200] = 4273.896
  data[49300] = 4894.557
  data[49400] = 5575.587
  data[49500] = 6522.164
  data[49600] = 7788.888
  data[49700] = 9954.084
  data[49800] = 13477.272
  data[49900] = 20305.637
=================================

Verifying array is sorted...
PASS: All 49999 adjacent pairs are in correct order!

=================================
Stress Test Complete!
Array size: 50000 elements
Total comparisons: ~O(n log n)
Specialized opcodes used:
  - ARRFETCH_FLT_G_OPT
  - ARRSTORE_FLT_G_OPT_OPT
  - ARRSTORE_FLT_G_OPT_STACK
=================================


+++ CURRENT OUTPUT +++
=================================
Array Sort Stress Test (-b)
50000 float elements - Quicksort
=================================

Filling array with 50000 random values...
Array filled.

Before sort - first 10 elements:
  data[0] = 824.572
  data[1] = 87.069
  data[2] = 1968.686
  data[9] = 117.519

Sorting array using quicksort...
Sort complete!

After sort - first 10 elements:
  data[0] = 0.005
  data[1] = 0.015
  data[2] = 0.017
  data[9] = 0.088

Every 100th element (should be ascending):
=================================
  data[0] = 0.005
  data[100] = 0.673
  data[200] = 1.244
  data[300] = 1.786
  data[400] = 2.413
  data[500] = 3.060
  data[600] = 3.660
  data[700] = 4.275
  data[800] = 4.893
  data[900] = 5.472
  data[1000] = 6.047
  data[1100] = 6.674
  data[1200] = 7.219
  data[1300] = 7.844
  data[1400] = 8.563
  data[1500] = 9.190
  data[1600] = 9.806
  data[1700] = 10.341
  data[1800] = 10.914
  data[1900] = 11.507
  data[2000] = 12.132
  data[2100] = 12.779
  data[2200] = 13.431
  data[2300] = 13.991
  data[2400] = 14.585
  data[2500] = 15.137
  data[2600] = 15.681
  data[2700] = 16.288
  data[2800] = 16.855
  data[2900] = 17.501
  data[3000] = 18.010
  data[3100] = 18.701
  data[3200] = 19.283
  data[3300] = 19.875
  data[3400] = 20.366
  data[3500] = 20.996
  data[3600] = 21.566
  data[3700] = 22.210
  data[3800] = 22.775
  data[3900] = 23.350
  data[4000] = 24.053
  data[4100] = 24.600
  data[4200] = 25.112
  data[4300] = 25.765
  data[4400] = 26.323
  data[4500] = 26.928
  data[4600] = 27.561
  data[4700] = 28.113
  data[4800] = 28.740
  data[4900] = 29.436
  data[5000] = 30.075
  data[5100] = 30.805
  data[5200] = 31.498
  data[5300] = 32.221
  data[5400] = 32.743
  data[5500] = 33.288
  data[5600] = 33.833
  data[5700] = 34.404
  data[5800] = 35.006
  data[5900] = 35.610
  data[6000] = 36.148
  data[6100] = 36.866
  data[6200] = 37.431
  data[6300] = 37.943
  data[6400] = 38.481
  data[6500] = 38.984
  data[6600] = 39.540
  data[6700] = 40.257
  data[6800] = 40.809
  data[6900] = 41.456
  data[7000] = 42.075
  data[7100] = 42.755
  data[7200] = 43.393
  data[7300] = 44.093
  data[7400] = 44.704
  data[7500] = 45.336
  data[7600] = 45.955
  data[7700] = 46.599
  data[7800] = 47.143
  data[7900] = 47.757
  data[8000] = 48.331
  data[8100] = 48.841
  data[8200] = 49.446
  data[8300] = 50.119
  data[8400] = 50.820
  data[8500] = 51.509
  data[8600] = 52.173
  data[8700] = 52.708
  data[8800] = 53.234
  data[8900] = 53.936
  data[9000] = 54.616
  data[9100] = 55.185
  data[9200] = 55.826
  data[9300] = 56.548
  data[9400] = 57.130
  data[9500] = 57.728
  data[9600] = 58.374
  data[9700] = 58.989
  data[9800] = 59.693
  data[9900] = 60.351
  data[10000] = 60.875
  data[10100] = 61.548
  data[10200] = 62.145
  data[10300] = 62.746
  data[10400] = 63.299
  data[10500] = 64.014
  data[10600] = 64.636
  data[10700] = 65.211
  data[10800] = 65.873
  data[10900] = 66.521
  data[11000] = 67.229
  data[11100] = 67.904
  data[11200] = 68.468
  data[11300] = 69.026
  data[11400] = 69.720
  data[11500] = 70.419
  data[11600] = 71.013
  data[11700] = 71.550
  data[11800] = 72.172
  data[11900] = 72.772
  data[12000] = 73.506
  data[12100] = 74.103
  data[12200] = 74.789
  data[12300] = 75.479
  data[12400] = 76.072
  data[12500] = 76.792
  data[12600] = 77.287
  data[12700] = 77.980
  data[12800] = 78.732
  data[12900] = 79.389
  data[13000] = 80.080
  data[13100] = 80.772
  data[13200] = 81.293
  data[13300] = 81.898
  data[13400] = 82.611
  data[13500] = 83.137
  data[13600] = 83.784
  data[13700] = 84.487
  data[13800] = 85.227
  data[13900] = 85.922
  data[14000] = 86.615
  data[14100] = 87.258
  data[14200] = 87.918
  data[14300] = 88.744
  data[14400] = 89.306
  data[14500] = 90.000
  data[14600] = 90.582
  data[14700] = 91.204
  data[14800] = 91.771
  data[14900] = 92.513
  data[15000] = 93.100
  data[15100] = 93.693
  data[15200] = 94.253
  data[15300] = 94.862
  data[15400] = 95.351
  data[15500] = 95.919
  data[15600] = 96.447
  data[15700] = 97.053
  data[15800] = 97.663
  data[15900] = 98.204
  data[16000] = 98.750
  data[16100] = 99.352
  data[16200] = 100.020
  data[16300] = 100.615
  data[16400] = 101.353
  data[16500] = 101.907
  data[16600] = 102.584
  data[16700] = 103.194
  data[16800] = 103.763
  data[16900] = 104.239
  data[17000] = 104.773
  data[17100] = 105.404
  data[17200] = 106.094
  data[17300] = 106.778
  data[17400] = 107.430
  data[17500] = 107.991
  data[17600] = 108.644
  data[17700] = 109.130
  data[17800] = 109.699
  data[17900] = 110.284
  data[18000] = 110.929
  data[18100] = 111.561
  data[18200] = 112.187
  data[18300] = 112.748
  data[18400] = 113.245
  data[18500] = 113.870
  data[18600] = 114.485
  data[18700] = 115.126
  data[18800] = 115.822
  data[18900] = 116.420
  data[19000] = 117.004
  data[19100] = 117.562
  data[19200] = 118.047
  data[19300] = 118.578
  data[19400] = 119.187
  data[19500] = 119.766
  data[19600] = 120.412
  data[19700] = 121.048
  data[19800] = 121.661
  data[19900] = 122.261
  data[20000] = 122.796
  data[20100] = 123.379
  data[20200] = 123.914
  data[20300] = 124.601
  data[20400] = 125.296
  data[20500] = 125.869
  data[20600] = 126.420
  data[20700] = 127.035
  data[20800] = 127.669
  data[20900] = 128.245
  data[21000] = 128.842
  data[21100] = 129.372
  data[21200] = 129.999
  data[21300] = 130.568
  data[21400] = 131.291
  data[21500] = 131.818
  data[21600] = 132.450
  data[21700] = 133.074
  data[21800] = 133.672
  data[21900] = 134.319
  data[22000] = 134.939
  data[22100] = 135.592
  data[22200] = 136.281
  data[22300] = 136.904
  data[22400] = 137.560
  data[22500] = 138.228
  data[22600] = 138.855
  data[22700] = 139.494
  data[22800] = 140.163
  data[22900] = 140.825
  data[23000] = 141.452
  data[23100] = 141.976
  data[23200] = 142.713
  data[23300] = 143.356
  data[23400] = 143.994
  data[23500] = 144.663
  data[23600] = 145.167
  data[23700] = 145.780
  data[23800] = 146.357
  data[23900] = 146.960
  data[24000] = 147.586
  data[24100] = 148.074
  data[24200] = 148.726
  data[24300] = 149.359
  data[24400] = 149.967
  data[24500] = 150.576
  data[24600] = 151.259
  data[24700] = 151.900
  data[24800] = 152.559
  data[24900] = 153.201
  data[25000] = 153.907
  data[25100] = 154.554
  data[25200] = 155.266
  data[25300] = 155.866
  data[25400] = 156.415
  data[25500] = 157.174
  data[25600] = 157.759
  data[25700] = 158.442
  data[25800] = 159.032
  data[25900] = 159.697
  data[26000] = 160.493
  data[26100] = 161.281
  data[26200] = 162.059
  data[26300] = 162.653
  data[26400] = 163.444
  data[26500] = 164.221
  data[26600] = 164.958
  data[26700] = 165.749
  data[26800] = 166.407
  data[26900] = 167.193
  data[27000] = 167.984
  data[27100] = 168.806
  data[27200] = 169.628
  data[27300] = 170.421
  data[27400] = 171.091
  data[27500] = 171.813
  data[27600] = 172.541
  data[27700] = 173.393
  data[27800] = 174.184
  data[27900] = 174.971
  data[28000] = 175.709
  data[28100] = 176.422
  data[28200] = 177.234
  data[28300] = 178.115
  data[28400] = 179.009
  data[28500] = 179.807
  data[28600] = 180.611
  data[28700] = 181.446
  data[28800] = 182.515
  data[28900] = 183.244
  data[29000] = 184.108
  data[29100] = 184.911
  data[29200] = 185.802
  data[29300] = 186.615
  data[29400] = 187.479
  data[29500] = 188.249
  data[29600] = 189.084
  data[29700] = 189.931
  data[29800] = 190.928
  data[29900] = 192.090
  data[30000] = 192.982
  data[30100] = 194.074
  data[30200] = 195.109
  data[30300] = 196.018
  data[30400] = 197.044
  data[30500] = 198.108
  data[30600] = 199.040
  data[30700] = 200.030
  data[30800] = 201.204
  data[30900] = 202.050
  data[31000] = 202.971
  data[31100] = 204.023
  data[31200] = 204.992
  data[31300] = 206.188
  data[31400] = 207.352
  data[31500] = 208.351
  data[31600] = 209.352
  data[31700] = 210.529
  data[31800] = 211.759
  data[31900] = 212.920
  data[32000] = 214.144
  data[32100] = 215.202
  data[32200] = 216.376
  data[32300] = 217.464
  data[32400] = 218.790
  data[32500] = 220.000
  data[32600] = 221.343
  data[32700] = 222.747
  data[32800] = 224.074
  data[32900] = 225.598
  data[33000] = 226.867
  data[33100] = 228.245
  data[33200] = 229.391
  data[33300] = 230.733
  data[33400] = 232.082
  data[33500] = 233.305
  data[33600] = 234.856
  data[33700] = 236.116
  data[33800] = 237.635
  data[33900] = 238.908
  data[34000] = 240.250
  data[34100] = 241.771
  data[34200] = 243.392
  data[34300] = 245.017
  data[34400] = 246.660
  data[34500] = 248.254
  data[34600] = 249.856
  data[34700] = 251.539
  data[34800] = 253.053
  data[34900] = 254.569
  data[35000] = 256.396
  data[35100] = 257.959
  data[35200] = 259.857
  data[35300] = 261.689
  data[35400] = 263.389
  data[35500] = 265.261
  data[35600] = 266.887
  data[35700] = 268.931
  data[35800] = 270.685
  data[35900] = 272.457
  data[36000] = 274.417
  data[36100] = 276.380
  data[36200] = 278.058
  data[36300] = 280.140
  data[36400] = 282.136
  data[36500] = 284.218
  data[36600] = 286.194
  data[36700] = 288.414
  data[36800] = 290.581
  data[36900] = 292.773
  data[37000] = 295.300
  data[37100] = 297.646
  data[37200] = 299.638
  data[37300] = 302.142
  data[37400] = 304.826
  data[37500] = 307.075
  data[37600] = 309.378
  data[37700] = 311.806
  data[37800] = 314.599
  data[37900] = 316.997
  data[38000] = 319.501
  data[38100] = 322.056
  data[38200] = 324.524
  data[38300] = 327.211
  data[38400] = 329.688
  data[38500] = 332.299
  data[38600] = 335.221
  data[38700] = 337.996
  data[38800] = 341.085
  data[38900] = 344.069
  data[39000] = 347.367
  data[39100] = 350.393
  data[39200] = 354.206
  data[39300] = 357.635
  data[39400] = 361.067
  data[39500] = 364.096
  data[39600] = 367.521
  data[39700] = 371.095
  data[39800] = 374.711
  data[39900] = 378.332
  data[40000] = 382.700
  data[40100] = 386.804
  data[40200] = 390.115
  data[40300] = 393.859
  data[40400] = 398.166
  data[40500] = 402.448
  data[40600] = 406.816
  data[40700] = 411.188
  data[40800] = 415.805
  data[40900] = 420.138
  data[41000] = 424.701
  data[41100] = 429.115
  data[41200] = 433.160
  data[41300] = 439.116
  data[41400] = 444.017
  data[41500] = 449.371
  data[41600] = 454.715
  data[41700] = 460.500
  data[41800] = 465.662
  data[41900] = 470.519
  data[42000] = 475.662
  data[42100] = 480.796
  data[42200] = 487.270
  data[42300] = 493.439
  data[42400] = 500.122
  data[42500] = 507.276
  data[42600] = 514.209
  data[42700] = 520.843
  data[42800] = 527.192
  data[42900] = 533.788
  data[43000] = 541.265
  data[43100] = 547.329
  data[43200] = 555.387
  data[43300] = 562.592
  data[43400] = 571.634
  data[43500] = 580.160
  data[43600] = 588.337
  data[43700] = 597.697
  data[43800] = 609.672
  data[43900] = 618.937
  data[44000] = 629.060
  data[44100] = 640.258
  data[44200] = 652.626
  data[44300] = 665.204
  data[44400] = 677.056
  data[44500] = 688.455
  data[44600] = 702.101
  data[44700] = 714.794
  data[44800] = 730.560
  data[44900] = 743.929
  data[45000] = 757.740
  data[45100] = 773.742
  data[45200] = 789.906
  data[45300] = 804.776
  data[45400] = 820.843
  data[45500] = 839.784
  data[45600] = 857.546
  data[45700] = 877.496
  data[45800] = 897.986
  data[45900] = 921.450
  data[46000] = 940.581
  data[46100] = 966.153
  data[46200] = 991.248
  data[46300] = 1021.413
  data[46400] = 1050.119
  data[46500] = 1080.116
  data[46600] = 1106.897
  data[46700] = 1140.762
  data[46800] = 1181.927
  data[46900] = 1217.524
  data[47000] = 1258.493
  data[47100] = 1300.389
  data[47200] = 1348.359
  data[47300] = 1392.019
  data[47400] = 1437.106
  data[47500] = 1494.984
  data[47600] = 1558.760
  data[47700] = 1624.337
  data[47800] = 1692.103
  data[47900] = 1763.548
  data[48000] = 1851.005
  data[48100] = 1935.856
  data[48200] = 2037.416
  data[48300] = 2142.584
  data[48400] = 2254.448
  data[48500] = 2403.824
  data[48600] = 2577.077
  data[48700] = 2772.398
  data[48800] = 3003.546
  data[48900] = 3229.777
  data[49000] = 3532.725
  data[49100] = 3870.279
  data[49200] = 4269.237
  data[49300] = 4761.104
  data[49400] = 5574.761
  data[49500] = 6633.044
  data[49600] = 8191.714
  data[49700] = 10299.316
  data[49800] = 13621.054
  data[49900] = 20617.062
=================================

Verifying array is sorted...
PASS: All 49999 adjacent pairs are in correct order!

=================================
Stress Test Complete!
Array size: 50000 elements
Total comparisons: ~O(n log n)
Specialized opcodes used:
  - ARRFETCH_FLT_G_OPT
  - ARRSTORE_FLT_G_OPT_OPT
  - ARRSTORE_FLT_G_OPT_STACK
=================================


--------------------------------------------------------------------------------
FILE: 20 array sort stress test.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
=================================
Array Sort Stress Test
50000 float elements - Quicksort
=================================

Filling array with 50000 random values...
Array filled.

Before sort - first 10 elements:
  data[0] = 169.207
  data[1] = 51.881
  data[2] = 74.167
  data[9] = 117.431

Sorting array using quicksort...
Sort complete!

After sort - first 10 elements:
  data[0] = 0.008
  data[1] = 0.015
  data[2] = 0.024
  data[9] = 0.056

Every 100th element (should be ascending):
=================================
  data[0] = 0.008
  data[100] = 0.628
  data[200] = 1.292
  data[300] = 2.062
  data[400] = 2.708
  data[500] = 3.272
  data[600] = 3.850
  data[700] = 4.411
  data[800] = 5.085
  data[900] = 5.772
  data[1000] = 6.382
  data[1100] = 6.908
  data[1200] = 7.467
  data[1300] = 8.121
  data[1400] = 8.823
  data[1500] = 9.409
  data[1600] = 9.993
  data[1700] = 10.708
  data[1800] = 11.342
  data[1900] = 12.015
  data[2000] = 12.526
  data[2100] = 13.039
  data[2200] = 13.615
  data[2300] = 14.215
  data[2400] = 14.862
  data[2500] = 15.468
  data[2600] = 15.992
  data[2700] = 16.591
  data[2800] = 17.185
  data[2900] = 17.764
  data[3000] = 18.428
  data[3100] = 18.998
  data[3200] = 19.618
  data[3300] = 20.267
  data[3400] = 20.874
  data[3500] = 21.472
  data[3600] = 21.989
  data[3700] = 22.644
  data[3800] = 23.269
  data[3900] = 23.817
  data[4000] = 24.444
  data[4100] = 25.195
  data[4200] = 25.735
  data[4300] = 26.482
  data[4400] = 27.131
  data[4500] = 27.790
  data[4600] = 28.528
  data[4700] = 29.222
  data[4800] = 29.718
  data[4900] = 30.357
  data[5000] = 30.960
  data[5100] = 31.676
  data[5200] = 32.421
  data[5300] = 33.010
  data[5400] = 33.728
  data[5500] = 34.265
  data[5600] = 34.916
  data[5700] = 35.502
  data[5800] = 36.163
  data[5900] = 36.716
  data[6000] = 37.318
  data[6100] = 38.115
  data[6200] = 38.727
  data[6300] = 39.183
  data[6400] = 39.800
  data[6500] = 40.450
  data[6600] = 41.080
  data[6700] = 41.641
  data[6800] = 42.312
  data[6900] = 42.977
  data[7000] = 43.466
  data[7100] = 44.007
  data[7200] = 44.719
  data[7300] = 45.346
  data[7400] = 45.906
  data[7500] = 46.576
  data[7600] = 47.169
  data[7700] = 47.923
  data[7800] = 48.498
  data[7900] = 49.080
  data[8000] = 49.746
  data[8100] = 50.360
  data[8200] = 51.020
  data[8300] = 51.603
  data[8400] = 52.222
  data[8500] = 52.957
  data[8600] = 53.548
  data[8700] = 54.227
  data[8800] = 54.922
  data[8900] = 55.685
  data[9000] = 56.428
  data[9100] = 56.935
  data[9200] = 57.501
  data[9300] = 58.123
  data[9400] = 58.664
  data[9500] = 59.225
  data[9600] = 59.766
  data[9700] = 60.378
  data[9800] = 61.012
  data[9900] = 61.685
  data[10000] = 62.239
  data[10100] = 62.864
  data[10200] = 63.510
  data[10300] = 64.104
  data[10400] = 64.728
  data[10500] = 65.270
  data[10600] = 65.829
  data[10700] = 66.497
  data[10800] = 67.109
  data[10900] = 67.580
  data[11000] = 68.370
  data[11100] = 69.100
  data[11200] = 69.686
  data[11300] = 70.346
  data[11400] = 70.923
  data[11500] = 71.499
  data[11600] = 72.075
  data[11700] = 72.677
  data[11800] = 73.406
  data[11900] = 74.119
  data[12000] = 74.705
  data[12100] = 75.314
  data[12200] = 75.911
  data[12300] = 76.500
  data[12400] = 77.112
  data[12500] = 77.771
  data[12600] = 78.397
  data[12700] = 79.013
  data[12800] = 79.680
  data[12900] = 80.289
  data[13000] = 80.850
  data[13100] = 81.430
  data[13200] = 82.124
  data[13300] = 82.735
  data[13400] = 83.326
  data[13500] = 83.973
  data[13600] = 84.699
  data[13700] = 85.330
  data[13800] = 85.911
  data[13900] = 86.436
  data[14000] = 87.004
  data[14100] = 87.636
  data[14200] = 88.289
  data[14300] = 88.937
  data[14400] = 89.575
  data[14500] = 90.112
  data[14600] = 90.691
  data[14700] = 91.362
  data[14800] = 91.951
  data[14900] = 92.519
  data[15000] = 93.098
  data[15100] = 93.719
  data[15200] = 94.346
  data[15300] = 95.037
  data[15400] = 95.566
  data[15500] = 96.168
  data[15600] = 96.870
  data[15700] = 97.473
  data[15800] = 98.201
  data[15900] = 98.861
  data[16000] = 99.397
  data[16100] = 100.113
  data[16200] = 100.730
  data[16300] = 101.250
  data[16400] = 101.849
  data[16500] = 102.449
  data[16600] = 103.000
  data[16700] = 103.532
  data[16800] = 104.289
  data[16900] = 104.934
  data[17000] = 105.476
  data[17100] = 106.110
  data[17200] = 106.696
  data[17300] = 107.301
  data[17400] = 107.841
  data[17500] = 108.519
  data[17600] = 109.020
  data[17700] = 109.599
  data[17800] = 110.186
  data[17900] = 110.725
  data[18000] = 111.339
  data[18100] = 111.985
  data[18200] = 112.647
  data[18300] = 113.253
  data[18400] = 113.848
  data[18500] = 114.462
  data[18600] = 115.047
  data[18700] = 115.718
  data[18800] = 116.442
  data[18900] = 117.074
  data[19000] = 117.601
  data[19100] = 118.270
  data[19200] = 118.829
  data[19300] = 119.425
  data[19400] = 119.985
  data[19500] = 120.638
  data[19600] = 121.232
  data[19700] = 121.851
  data[19800] = 122.410
  data[19900] = 123.079
  data[20000] = 123.675
  data[20100] = 124.296
  data[20200] = 124.836
  data[20300] = 125.433
  data[20400] = 126.045
  data[20500] = 126.727
  data[20600] = 127.470
  data[20700] = 128.030
  data[20800] = 128.716
  data[20900] = 129.314
  data[21000] = 129.908
  data[21100] = 130.590
  data[21200] = 131.094
  data[21300] = 131.829
  data[21400] = 132.435
  data[21500] = 133.030
  data[21600] = 133.686
  data[21700] = 134.255
  data[21800] = 134.864
  data[21900] = 135.417
  data[22000] = 136.120
  data[22100] = 136.743
  data[22200] = 137.360
  data[22300] = 137.970
  data[22400] = 138.668
  data[22500] = 139.226
  data[22600] = 139.774
  data[22700] = 140.439
  data[22800] = 141.064
  data[22900] = 141.704
  data[23000] = 142.356
  data[23100] = 143.056
  data[23200] = 143.619
  data[23300] = 144.294
  data[23400] = 144.878
  data[23500] = 145.578
  data[23600] = 146.183
  data[23700] = 146.843
  data[23800] = 147.434
  data[23900] = 147.972
  data[24000] = 148.588
  data[24100] = 149.221
  data[24200] = 149.960
  data[24300] = 150.689
  data[24400] = 151.209
  data[24500] = 151.807
  data[24600] = 152.406
  data[24700] = 153.172
  data[24800] = 153.885
  data[24900] = 154.477
  data[25000] = 155.151
  data[25100] = 155.852
  data[25200] = 156.473
  data[25300] = 157.098
  data[25400] = 157.708
  data[25500] = 158.311
  data[25600] = 158.866
  data[25700] = 159.527
  data[25800] = 160.179
  data[25900] = 160.775
  data[26000] = 161.429
  data[26100] = 162.225
  data[26200] = 162.951
  data[26300] = 163.681
  data[26400] = 164.337
  data[26500] = 165.084
  data[26600] = 165.792
  data[26700] = 166.502
  data[26800] = 167.295
  data[26900] = 167.955
  data[27000] = 168.818
  data[27100] = 169.523
  data[27200] = 170.151
  data[27300] = 171.004
  data[27400] = 171.835
  data[27500] = 172.536
  data[27600] = 173.314
  data[27700] = 174.102
  data[27800] = 174.835
  data[27900] = 175.790
  data[28000] = 176.447
  data[28100] = 177.229
  data[28200] = 178.072
  data[28300] = 178.750
  data[28400] = 179.521
  data[28500] = 180.173
  data[28600] = 180.965
  data[28700] = 181.866
  data[28800] = 182.632
  data[28900] = 183.421
  data[29000] = 184.271
  data[29100] = 185.091
  data[29200] = 185.908
  data[29300] = 186.717
  data[29400] = 187.614
  data[29500] = 188.413
  data[29600] = 189.296
  data[29700] = 190.378
  data[29800] = 191.361
  data[29900] = 192.211
  data[30000] = 193.164
  data[30100] = 194.116
  data[30200] = 195.142
  data[30300] = 196.182
  data[30400] = 197.360
  data[30500] = 198.247
  data[30600] = 199.423
  data[30700] = 200.338
  data[30800] = 201.377
  data[30900] = 202.386
  data[31000] = 203.276
  data[31100] = 204.328
  data[31200] = 205.513
  data[31300] = 206.605
  data[31400] = 207.830
  data[31500] = 209.179
  data[31600] = 210.429
  data[31700] = 211.568
  data[31800] = 212.540
  data[31900] = 213.842
  data[32000] = 215.070
  data[32100] = 216.246
  data[32200] = 217.392
  data[32300] = 218.583
  data[32400] = 219.890
  data[32500] = 221.041
  data[32600] = 222.394
  data[32700] = 223.707
  data[32800] = 224.922
  data[32900] = 226.204
  data[33000] = 227.483
  data[33100] = 228.732
  data[33200] = 230.187
  data[33300] = 231.502
  data[33400] = 232.703
  data[33500] = 234.130
  data[33600] = 235.644
  data[33700] = 237.206
  data[33800] = 238.980
  data[33900] = 240.203
  data[34000] = 242.028
  data[34100] = 243.700
  data[34200] = 245.191
  data[34300] = 246.815
  data[34400] = 248.283
  data[34500] = 249.926
  data[34600] = 251.359
  data[34700] = 252.773
  data[34800] = 254.192
  data[34900] = 255.743
  data[35000] = 257.875
  data[35100] = 259.650
  data[35200] = 261.798
  data[35300] = 263.276
  data[35400] = 265.068
  data[35500] = 267.022
  data[35600] = 268.898
  data[35700] = 270.652
  data[35800] = 272.630
  data[35900] = 274.537
  data[36000] = 276.384
  data[36100] = 278.461
  data[36200] = 280.073
  data[36300] = 282.396
  data[36400] = 284.157
  data[36500] = 286.326
  data[36600] = 288.639
  data[36700] = 290.828
  data[36800] = 293.425
  data[36900] = 295.542
  data[37000] = 297.776
  data[37100] = 299.865
  data[37200] = 301.757
  data[37300] = 304.100
  data[37400] = 306.892
  data[37500] = 309.642
  data[37600] = 311.783
  data[37700] = 314.124
  data[37800] = 316.589
  data[37900] = 319.153
  data[38000] = 321.759
  data[38100] = 324.306
  data[38200] = 326.645
  data[38300] = 329.454
  data[38400] = 331.947
  data[38500] = 334.714
  data[38600] = 337.463
  data[38700] = 340.217
  data[38800] = 343.258
  data[38900] = 346.301
  data[39000] = 349.658
  data[39100] = 352.784
  data[39200] = 355.657
  data[39300] = 358.352
  data[39400] = 361.829
  data[39500] = 365.344
  data[39600] = 368.739
  data[39700] = 372.231
  data[39800] = 375.643
  data[39900] = 379.381
  data[40000] = 383.398
  data[40100] = 388.158
  data[40200] = 391.661
  data[40300] = 396.442
  data[40400] = 400.612
  data[40500] = 404.730
  data[40600] = 408.782
  data[40700] = 413.881
  data[40800] = 418.428
  data[40900] = 423.306
  data[41000] = 427.869
  data[41100] = 432.552
  data[41200] = 437.228
  data[41300] = 441.308
  data[41400] = 445.802
  data[41500] = 451.795
  data[41600] = 457.016
  data[41700] = 462.825
  data[41800] = 468.555
  data[41900] = 475.244
  data[42000] = 481.052
  data[42100] = 487.757
  data[42200] = 493.417
  data[42300] = 500.983
  data[42400] = 506.197
  data[42500] = 513.247
  data[42600] = 519.777
  data[42700] = 527.674
  data[42800] = 534.731
  data[42900] = 541.117
  data[43000] = 549.071
  data[43100] = 557.578
  data[43200] = 565.231
  data[43300] = 575.448
  data[43400] = 583.632
  data[43500] = 592.686
  data[43600] = 603.058
  data[43700] = 614.110
  data[43800] = 623.903
  data[43900] = 633.791
  data[44000] = 644.909
  data[44100] = 655.189
  data[44200] = 666.957
  data[44300] = 679.771
  data[44400] = 693.189
  data[44500] = 704.203
  data[44600] = 715.528
  data[44700] = 729.170
  data[44800] = 741.448
  data[44900] = 754.206
  data[45000] = 765.480
  data[45100] = 781.776
  data[45200] = 798.528
  data[45300] = 816.316
  data[45400] = 834.660
  data[45500] = 851.354
  data[45600] = 870.623
  data[45700] = 887.458
  data[45800] = 907.283
  data[45900] = 927.755
  data[46000] = 948.342
  data[46100] = 979.781
  data[46200] = 1005.671
  data[46300] = 1033.820
  data[46400] = 1058.271
  data[46500] = 1086.192
  data[46600] = 1114.016
  data[46700] = 1143.475
  data[46800] = 1175.499
  data[46900] = 1218.202
  data[47000] = 1260.902
  data[47100] = 1308.799
  data[47200] = 1347.642
  data[47300] = 1397.541
  data[47400] = 1448.876
  data[47500] = 1509.779
  data[47600] = 1570.970
  data[47700] = 1638.224
  data[47800] = 1710.320
  data[47900] = 1786.706
  data[48000] = 1880.649
  data[48100] = 1979.165
  data[48200] = 2088.236
  data[48300] = 2192.183
  data[48400] = 2328.638
  data[48500] = 2492.367
  data[48600] = 2664.627
  data[48700] = 2840.719
  data[48800] = 3041.917
  data[48900] = 3306.866
  data[49000] = 3590.844
  data[49100] = 4077.730
  data[49200] = 4513.125
  data[49300] = 5069.083
  data[49400] = 5786.834
  data[49500] = 6703.914
  data[49600] = 8328.639
  data[49700] = 10000.997
  data[49800] = 13455.896
  data[49900] = 20844.320
=================================

Verifying array is sorted...
PASS: All 49999 adjacent pairs are in correct order!

=================================
Stress Test Complete!
Array size: 50000 elements
Total comparisons: ~O(n log n)
Specialized opcodes used:
  - ARRFETCH_FLT_G_OPT
  - ARRSTORE_FLT_G_OPT_OPT
  - ARRSTORE_FLT_G_OPT_STACK
=================================


+++ CURRENT OUTPUT +++
=================================
Array Sort Stress Test
50000 float elements - Quicksort
=================================

Filling array with 50000 random values...
Array filled.

Before sort - first 10 elements:
  data[0] = 855.090
  data[1] = 96.252
  data[2] = 99.241
  data[9] = 196.168

Sorting array using quicksort...
Sort complete!

After sort - first 10 elements:
  data[0] = 0.016
  data[1] = 0.022
  data[2] = 0.028
  data[9] = 0.055

Every 100th element (should be ascending):
=================================
  data[0] = 0.016
  data[100] = 0.574
  data[200] = 1.232
  data[300] = 1.831
  data[400] = 2.425
  data[500] = 3.080
  data[600] = 3.905
  data[700] = 4.545
  data[800] = 5.102
  data[900] = 5.754
  data[1000] = 6.481
  data[1100] = 7.194
  data[1200] = 7.734
  data[1300] = 8.329
  data[1400] = 8.933
  data[1500] = 9.575
  data[1600] = 10.196
  data[1700] = 10.792
  data[1800] = 11.479
  data[1900] = 12.130
  data[2000] = 12.694
  data[2100] = 13.303
  data[2200] = 13.880
  data[2300] = 14.586
  data[2400] = 15.197
  data[2500] = 15.814
  data[2600] = 16.536
  data[2700] = 17.207
  data[2800] = 17.819
  data[2900] = 18.514
  data[3000] = 19.109
  data[3100] = 19.823
  data[3200] = 20.509
  data[3300] = 21.104
  data[3400] = 21.696
  data[3500] = 22.358
  data[3600] = 22.974
  data[3700] = 23.636
  data[3800] = 24.255
  data[3900] = 24.971
  data[4000] = 25.535
  data[4100] = 26.104
  data[4200] = 26.715
  data[4300] = 27.355
  data[4400] = 27.918
  data[4500] = 28.515
  data[4600] = 29.057
  data[4700] = 29.621
  data[4800] = 30.225
  data[4900] = 30.860
  data[5000] = 31.486
  data[5100] = 32.037
  data[5200] = 32.731
  data[5300] = 33.359
  data[5400] = 33.973
  data[5500] = 34.558
  data[5600] = 35.232
  data[5700] = 35.798
  data[5800] = 36.436
  data[5900] = 37.089
  data[6000] = 37.856
  data[6100] = 38.464
  data[6200] = 39.065
  data[6300] = 39.770
  data[6400] = 40.353
  data[6500] = 40.922
  data[6600] = 41.387
  data[6700] = 41.953
  data[6800] = 42.555
  data[6900] = 43.306
  data[7000] = 43.889
  data[7100] = 44.590
  data[7200] = 45.200
  data[7300] = 45.861
  data[7400] = 46.519
  data[7500] = 47.067
  data[7600] = 47.723
  data[7700] = 48.298
  data[7800] = 48.892
  data[7900] = 49.471
  data[8000] = 50.143
  data[8100] = 50.723
  data[8200] = 51.377
  data[8300] = 52.072
  data[8400] = 52.612
  data[8500] = 53.193
  data[8600] = 53.793
  data[8700] = 54.397
  data[8800] = 55.036
  data[8900] = 55.568
  data[9000] = 56.205
  data[9100] = 56.877
  data[9200] = 57.393
  data[9300] = 57.925
  data[9400] = 58.455
  data[9500] = 59.019
  data[9600] = 59.618
  data[9700] = 60.272
  data[9800] = 60.953
  data[9900] = 61.590
  data[10000] = 62.206
  data[10100] = 62.807
  data[10200] = 63.480
  data[10300] = 64.054
  data[10400] = 64.769
  data[10500] = 65.447
  data[10600] = 66.065
  data[10700] = 66.647
  data[10800] = 67.263
  data[10900] = 67.970
  data[11000] = 68.512
  data[11100] = 69.169
  data[11200] = 69.725
  data[11300] = 70.277
  data[11400] = 70.831
  data[11500] = 71.510
  data[11600] = 72.185
  data[11700] = 72.814
  data[11800] = 73.427
  data[11900] = 74.166
  data[12000] = 74.852
  data[12100] = 75.479
  data[12200] = 76.068
  data[12300] = 76.673
  data[12400] = 77.309
  data[12500] = 77.915
  data[12600] = 78.429
  data[12700] = 79.048
  data[12800] = 79.638
  data[12900] = 80.287
  data[13000] = 80.893
  data[13100] = 81.488
  data[13200] = 82.184
  data[13300] = 82.914
  data[13400] = 83.457
  data[13500] = 84.158
  data[13600] = 84.772
  data[13700] = 85.454
  data[13800] = 86.192
  data[13900] = 86.822
  data[14000] = 87.517
  data[14100] = 88.112
  data[14200] = 88.771
  data[14300] = 89.456
  data[14400] = 90.148
  data[14500] = 90.746
  data[14600] = 91.353
  data[14700] = 91.905
  data[14800] = 92.589
  data[14900] = 93.272
  data[15000] = 93.836
  data[15100] = 94.464
  data[15200] = 95.079
  data[15300] = 95.653
  data[15400] = 96.347
  data[15500] = 96.942
  data[15600] = 97.540
  data[15700] = 98.098
  data[15800] = 98.729
  data[15900] = 99.299
  data[16000] = 99.842
  data[16100] = 100.569
  data[16200] = 101.118
  data[16300] = 101.768
  data[16400] = 102.354
  data[16500] = 102.983
  data[16600] = 103.661
  data[16700] = 104.252
  data[16800] = 104.859
  data[16900] = 105.503
  data[17000] = 106.122
  data[17100] = 106.652
  data[17200] = 107.318
  data[17300] = 107.914
  data[17400] = 108.547
  data[17500] = 109.142
  data[17600] = 109.629
  data[17700] = 110.202
  data[17800] = 110.837
  data[17900] = 111.443
  data[18000] = 112.144
  data[18100] = 112.804
  data[18200] = 113.477
  data[18300] = 114.207
  data[18400] = 114.794
  data[18500] = 115.436
  data[18600] = 116.084
  data[18700] = 116.683
  data[18800] = 117.186
  data[18900] = 117.900
  data[19000] = 118.574
  data[19100] = 119.237
  data[19200] = 119.800
  data[19300] = 120.483
  data[19400] = 121.085
  data[19500] = 121.751
  data[19600] = 122.380
  data[19700] = 123.192
  data[19800] = 123.855
  data[19900] = 124.489
  data[20000] = 125.022
  data[20100] = 125.460
  data[20200] = 126.128
  data[20300] = 126.780
  data[20400] = 127.437
  data[20500] = 128.011
  data[20600] = 128.649
  data[20700] = 129.402
  data[20800] = 130.111
  data[20900] = 130.686
  data[21000] = 131.306
  data[21100] = 131.878
  data[21200] = 132.423
  data[21300] = 133.028
  data[21400] = 133.714
  data[21500] = 134.364
  data[21600] = 135.078
  data[21700] = 135.677
  data[21800] = 136.289
  data[21900] = 136.955
  data[22000] = 137.467
  data[22100] = 138.094
  data[22200] = 138.709
  data[22300] = 139.288
  data[22400] = 140.049
  data[22500] = 140.627
  data[22600] = 141.140
  data[22700] = 141.763
  data[22800] = 142.341
  data[22900] = 142.956
  data[23000] = 143.581
  data[23100] = 144.260
  data[23200] = 144.958
  data[23300] = 145.562
  data[23400] = 146.178
  data[23500] = 146.816
  data[23600] = 147.431
  data[23700] = 148.046
  data[23800] = 148.595
  data[23900] = 149.334
  data[24000] = 150.018
  data[24100] = 150.627
  data[24200] = 151.163
  data[24300] = 151.732
  data[24400] = 152.429
  data[24500] = 152.981
  data[24600] = 153.531
  data[24700] = 154.104
  data[24800] = 154.743
  data[24900] = 155.349
  data[25000] = 156.051
  data[25100] = 156.645
  data[25200] = 157.325
  data[25300] = 157.966
  data[25400] = 158.528
  data[25500] = 159.086
  data[25600] = 159.631
  data[25700] = 160.268
  data[25800] = 160.935
  data[25900] = 161.621
  data[26000] = 162.145
  data[26100] = 162.853
  data[26200] = 163.568
  data[26300] = 164.313
  data[26400] = 165.008
  data[26500] = 165.699
  data[26600] = 166.409
  data[26700] = 167.111
  data[26800] = 167.769
  data[26900] = 168.502
  data[27000] = 169.383
  data[27100] = 170.077
  data[27200] = 170.848
  data[27300] = 171.536
  data[27400] = 172.337
  data[27500] = 173.025
  data[27600] = 173.781
  data[27700] = 174.447
  data[27800] = 175.277
  data[27900] = 176.104
  data[28000] = 176.937
  data[28100] = 177.638
  data[28200] = 178.361
  data[28300] = 179.136
  data[28400] = 179.960
  data[28500] = 180.779
  data[28600] = 181.612
  data[28700] = 182.599
  data[28800] = 183.313
  data[28900] = 184.100
  data[29000] = 185.011
  data[29100] = 185.818
  data[29200] = 186.773
  data[29300] = 187.629
  data[29400] = 188.522
  data[29500] = 189.515
  data[29600] = 190.565
  data[29700] = 191.362
  data[29800] = 192.119
  data[29900] = 193.191
  data[30000] = 194.066
  data[30100] = 195.089
  data[30200] = 196.014
  data[30300] = 197.082
  data[30400] = 197.976
  data[30500] = 199.076
  data[30600] = 200.017
  data[30700] = 200.957
  data[30800] = 201.919
  data[30900] = 202.896
  data[31000] = 204.157
  data[31100] = 205.381
  data[31200] = 206.427
  data[31300] = 207.721
  data[31400] = 208.934
  data[31500] = 210.215
  data[31600] = 211.425
  data[31700] = 212.485
  data[31800] = 213.510
  data[31900] = 214.686
  data[32000] = 215.910
  data[32100] = 217.063
  data[32200] = 218.436
  data[32300] = 219.576
  data[32400] = 220.898
  data[32500] = 221.917
  data[32600] = 222.918
  data[32700] = 224.284
  data[32800] = 225.650
  data[32900] = 227.033
  data[33000] = 228.202
  data[33100] = 229.514
  data[33200] = 231.000
  data[33300] = 232.161
  data[33400] = 233.560
  data[33500] = 235.190
  data[33600] = 236.766
  data[33700] = 238.415
  data[33800] = 239.882
  data[33900] = 241.212
  data[34000] = 242.861
  data[34100] = 244.517
  data[34200] = 246.039
  data[34300] = 247.366
  data[34400] = 249.039
  data[34500] = 250.879
  data[34600] = 252.415
  data[34700] = 253.973
  data[34800] = 255.657
  data[34900] = 257.390
  data[35000] = 259.020
  data[35100] = 260.550
  data[35200] = 262.474
  data[35300] = 264.357
  data[35400] = 266.177
  data[35500] = 268.334
  data[35600] = 270.138
  data[35700] = 272.135
  data[35800] = 274.208
  data[35900] = 276.045
  data[36000] = 277.442
  data[36100] = 279.255
  data[36200] = 281.425
  data[36300] = 283.449
  data[36400] = 285.370
  data[36500] = 287.515
  data[36600] = 289.635
  data[36700] = 291.648
  data[36800] = 293.906
  data[36900] = 296.137
  data[37000] = 298.527
  data[37100] = 300.633
  data[37200] = 303.388
  data[37300] = 305.742
  data[37400] = 308.309
  data[37500] = 310.571
  data[37600] = 313.094
  data[37700] = 315.873
  data[37800] = 318.616
  data[37900] = 321.332
  data[38000] = 323.858
  data[38100] = 326.547
  data[38200] = 328.835
  data[38300] = 331.291
  data[38400] = 333.901
  data[38500] = 336.834
  data[38600] = 339.252
  data[38700] = 342.085
  data[38800] = 344.675
  data[38900] = 348.285
  data[39000] = 351.705
  data[39100] = 354.511
  data[39200] = 357.978
  data[39300] = 361.404
  data[39400] = 364.916
  data[39500] = 368.018
  data[39600] = 371.406
  data[39700] = 375.227
  data[39800] = 378.895
  data[39900] = 382.650
  data[40000] = 387.468
  data[40100] = 391.365
  data[40200] = 395.077
  data[40300] = 398.632
  data[40400] = 403.083
  data[40500] = 407.822
  data[40600] = 411.933
  data[40700] = 416.722
  data[40800] = 421.504
  data[40900] = 425.569
  data[41000] = 430.164
  data[41100] = 435.047
  data[41200] = 439.812
  data[41300] = 443.599
  data[41400] = 448.794
  data[41500] = 453.507
  data[41600] = 459.891
  data[41700] = 465.604
  data[41800] = 470.636
  data[41900] = 476.926
  data[42000] = 484.167
  data[42100] = 489.966
  data[42200] = 495.456
  data[42300] = 500.860
  data[42400] = 507.789
  data[42500] = 515.889
  data[42600] = 522.730
  data[42700] = 529.423
  data[42800] = 536.285
  data[42900] = 543.659
  data[43000] = 551.544
  data[43100] = 559.265
  data[43200] = 568.289
  data[43300] = 574.697
  data[43400] = 583.411
  data[43500] = 592.096
  data[43600] = 601.396
  data[43700] = 611.648
  data[43800] = 622.014
  data[43900] = 630.785
  data[44000] = 640.494
  data[44100] = 650.525
  data[44200] = 659.938
  data[44300] = 671.769
  data[44400] = 683.644
  data[44500] = 696.391
  data[44600] = 708.611
  data[44700] = 723.922
  data[44800] = 736.765
  data[44900] = 748.176
  data[45000] = 763.055
  data[45100] = 778.845
  data[45200] = 795.736
  data[45300] = 814.138
  data[45400] = 831.316
  data[45500] = 846.723
  data[45600] = 865.096
  data[45700] = 883.713
  data[45800] = 901.030
  data[45900] = 923.382
  data[46000] = 942.574
  data[46100] = 968.119
  data[46200] = 995.359
  data[46300] = 1021.699
  data[46400] = 1051.481
  data[46500] = 1079.306
  data[46600] = 1107.517
  data[46700] = 1136.838
  data[46800] = 1174.937
  data[46900] = 1205.501
  data[47000] = 1241.755
  data[47100] = 1284.647
  data[47200] = 1331.590
  data[47300] = 1378.708
  data[47400] = 1426.488
  data[47500] = 1476.784
  data[47600] = 1546.051
  data[47700] = 1614.492
  data[47800] = 1692.208
  data[47900] = 1774.663
  data[48000] = 1861.498
  data[48100] = 1963.062
  data[48200] = 2057.537
  data[48300] = 2183.689
  data[48400] = 2314.160
  data[48500] = 2460.253
  data[48600] = 2635.037
  data[48700] = 2868.644
  data[48800] = 3078.243
  data[48900] = 3287.028
  data[49000] = 3627.933
  data[49100] = 3936.976
  data[49200] = 4305.839
  data[49300] = 4787.942
  data[49400] = 5503.927
  data[49500] = 6426.244
  data[49600] = 7886.878
  data[49700] = 9649.522
  data[49800] = 12933.931
  data[49900] = 20853.779
=================================

Verifying array is sorted...
PASS: All 49999 adjacent pairs are in correct order!

=================================
Stress Test Complete!
Array size: 50000 elements
Total comparisons: ~O(n log n)
Specialized opcodes used:
  - ARRFETCH_FLT_G_OPT
  - ARRSTORE_FLT_G_OPT_OPT
  - ARRSTORE_FLT_G_OPT_STACK
=================================


--------------------------------------------------------------------------------
FILE: 21 Julia Set-b.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
0000000000000000011111222222222222222222222222222221111111111111111111111111111111110000000000000000
0000000000000001111122222222222222222222333333454432111111111111111111111111111111111100000000000000
0000000000000111111223345544333322233333333334445633321111111111111111111111111111111111000000000000
0000000000001111111333344565333333333333333334444433332111111111111111111111111111111111100000000000
0000000000111111112334444443333333333333333344444433332211111111111111111111111111111111111000000000
0000000001111111112454443333333333333333333444444443332221111111111111111111111111111111111100000000
0000000111111111122234333333333333333333333566555543322222111111111111111111111111111111111111000000
0000001111111111112222333333333333333333333495545753222222111111111111111111111111111111111111100000
0000011111111111112222222222222222233333333333444322222222211111111111111111111111111111111111110000
0000111111111111112222222222222222222222222222222222222222211111111111111111111111111111111111111000
0000111111111111111222222222222222222222222222222222222222221111111111111111111111111111111111111000
0001111111111111111222222222222222222222222222222222222222221111111111111111111111111111111111111100
0011111111111111111122222222222222222222222222222222222222222111111111111111111111111111111111111110
0011111111111111111112222222222222222222222222222222222222222211111111111111111111111111111111111110
0111111111111111111111122222222222222222222222222222222222222211111111111111111111111111111111111111
0111111111111111111111112222222222222222222222222222222222222221111111111111111111111111111111111111
0111111111111111111111111122222222222222222222222222222222222222211111111111111111111111111111111111
0111111111111111111111111111222222222222222222222222222222222222221111111111111111111111111111111111
1111111111111111111111111111112222222222222222222222222222222222222211111111111111111111111111111111
1111111111111111111111111111111122222222222222222222222222222222222222111111111111111111111111111111
0111111111111111111111111111111111222222222222222222222222222222222222221111111111111111111111111111
0111111111111111111111111111111111112222222222222222222222222222222222222211111111111111111111111111
0111111111111111111111111111111111111222222222222222222222222222222222222222111111111111111111111111
0111111111111111111111111111111111111122222222222222222222222222222222222222211111111111111111111111
0011111111111111111111111111111111111112222222222222222222222222222222222222222111111111111111111110
0011111111111111111111111111111111111111222222222222222222222222222222222222222211111111111111111110
0001111111111111111111111111111111111111222222222222222222222222222222222222222221111111111111111100
0001111111111111111111111111111111111111122222222222222222222222222222222222222222111111111111111100
0000111111111111111111111111111111111111122222222222222222222222222222222222222222211111111111111000
0000011111111111111111111111111111111111112222222222233333333322222222222222222222211111111111110000
0000001111111111111111111111111111111111112222222234444443333333333333333333332222211111111111100000
0000000111111111111111111111111111111111111222223365555565333333333333333333333322221111111111000000
0000000011111111111111111111111111111111111122233344445654333333333333333333334454221111111110000000
0000000001111111111111111111111111111111111122233334444443333333333333333334444463211111111100000000
0000000000011111111111111111111111111111111112233334444433333333333333333444444333211111110000000000
0000000000001111111111111111111111111111111111123334444433333333333333333955443332111111100000000000
0000000000000011111111111111111111111111111111112335544333333332222222223334332221111110000000000000
0000000000000000111111111111111111111111111111111222333333222222222222222222222211111000000000000000

Julia Set with c = 84 + 142i (scaled by 100)


+++ CURRENT OUTPUT +++
0000000000000000011111111111111111111111111111111111111111111111111111111111111111110000000000000000
0000000000000001111111111111111111111111111111111111111111111111111111111111111111111100000000000000
0000000000000111111111111111111111111111111122222222222222222222221111111111111111111111000000000000
0000000000001111111111111111111111111112222222222222222222222222222222211111111111111111100000000000
0000000000111111111111111111111111122222222222222333333322222222222222222211111111111111111000000000
0000000001111111111111111111111122222222223333333333333333333333222222222222111111111111111100000000
00000001111111111111111111111122222222233334445    6554444444333333332222222221111111111111111000000
000000111111111111111111111222222222333334588         @ 86666655444443333222222211111111111111100000
000001111111111111111111112222222233334457                          86543332222221111111111111110000
0000111111111111111111112222222233334456                               64433322222211111111111111000
000011111111111111111122222222233344557                                 7544333222221111111111111000
0001111111111111111112222222233344579                                     75433322221111111111111100
0011111111111111111122222222333458                                           43322222111111111111110
001111111111111111122222222333459                                            54332222211111111111110
01111111111111111122222222333446                                              5332222211111111111111
01111111111111111222222223334457                                              5332222211111111111111
0111111111111111222222223334467                                             654332222211111111111111
01111111111111112222222333446                                             85443332222211111111111111
11111111111111122222223333457                                             54433322222211111111111111
1111111111111112222223334456                                            9644333322222211111111111111
011111111111111222223334456                                             7543333222222111111111111111
01111111111111122222334458                                             @5433332222222111111111111111
01111111111111122222334                                               654333322222221111111111111111
01111111111111122222345                                              6544333222222221111111111111111
001111111111111222223347                                             5443332222222211111111111111110
001111111111111122223345                                            54433322222222111111111111111110
00011111111111112222233458                                         543332222222221111111111111111100
000111111111111112222233345@                                   7654433322222222111111111111111111100
000011111111111111222223334458                               855443332222222221111111111111111111000
000001111111111111122222233345                              6544333322222222111111111111111111110000
00000011111111111111222222233334455567                    @54333332222222221111111111111111111100000
0000000111111111111111222222223333344444445555567      654433333222222221111111111111111111111000000
0000000011111111111111122222222222333333333334444455544433333222222222111111111111111111111110000000
0000000001111111111111111122222222222222333333333333333332222222222111111111111111111111111100000000
0000000000011111111111111111222222222222222222222222222222222222111111111111111111111111110000000000
0000000000001111111111111111111122222222222222222222222222221111111111111111111111111111100000000000
0000000000000011111111111111111111111122222222222222211111111111111111111111111111111110000000000000
0000000000000000111111111111111111111111111111111111111111111111111111111111111111111000000000000000

Julia Set with c = -2 + -28i (scaled by 100)


--------------------------------------------------------------------------------
FILE: 21 Julia Set.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
0000000000000000011111111111111111111111111111111111111111111111111111111111111111110000000000000000
0000000000000001111111111111111111111111111111111111111111111111111111111111111111111100000000000000
0000000000000111111111111111111111111111111111111111111111111111111111111111111111111111000000000000
0000000000001111111111111122222222222222221111111111111111111111111111111111111111111111100000000000
0000000000111111111112222222222222222222222222221111111111111111111111111111111111111111111000000000
0000000001111111112222222222222222222222222222222222111111111111111111111111111111111111111100000000
0000000111111111222222222222222222233333333333333222222211111111111111111111111111111111111111000000
000000111111112222222222222223333333333334445@@44333222222221111111111111111111111111111111111100000
0000011111111222222223333333333333333344445679875433333222222222111111111111111111111111111111110000
000011111111222233334@65444444444444555555789@@9@@43333332222222222111111111111111111111111111111000
0000111111122233334458976554445557988666666788777554333333322222222222211111111111111111111111111000
0001111111222333445988987655555667@@8887777766665544333333332222222222222211111111111111111111111100
00111111112234597678@@@@@766566667889@@@@88776655544443333333222222222222222211111111111111111111110
001111111122368897668998776666677799@@@@@99877665444444333333332222222222222222211111111111111111110
011111111122234444556@@@665555568@@@@@@@@@@@@@@65444444443333333322222222222222222111111111111111111
01111111112222333334445555555556789999@@@99@@8765444444444443333333222222222222222221111111111111111
0111111111222223333333344444455566778887777766655444444444444444433332222222222222222211111111111111
0111111111122222223333333344444566778877766666555554444444444555575433332222222222222221111111111111
111111111112222222222333333444457@@@@987665555555555555555555556897554433332222222222222111111111111
1111111111112222222222222333344456@@99765555555555555555555566@@@@@764444333332222222222211111111111
0111111111111222222222222222333345@@65555544444445555555566667789@9865444433333333222222221111111111
0111111111111112222222222222222333344444444444444445556666677778877665544444333333333222221111111111
0111111111111111222222222222222223333344444444444445556678888899887765555554444333333332222111111111
01111111111111111122222222222222222333333344444444445679@@99@@@@@@@@7655555566@654444333222111111111
00111111111111111111222222222222222223333333344444445689@@@9@@@@@@@976665666689876557555322111111110
001111111111111111111112222222222222222333333334444556667789@@@@@8877666666779@@@877@@74322111111110
0001111111111111111111111222222222222222333333334445556677789@98998766555567@@@@@@655643322111111100
00011111111111111111111111112222222222222233333334455666776666779@@765555555678765443333221111111100
0000111111111111111111111111111122222222222333333346989@876655555665444444446@@754333322221111111000
000001111111111111111111111111111112222222222333334568@@9@754444433333333344444333322222211111110000
0000001111111111111111111111111111111112222222233334457865444333333333333332222222222221111111100000
0000000111111111111111111111111111111111111222222233345944433333333332222222222222222211111111000000
0000000011111111111111111111111111111111111111122222222333333332222222222222222222221111111110000000
0000000001111111111111111111111111111111111111111112222222222222222222222222222221111111111100000000
0000000000011111111111111111111111111111111111111111111122222222222222222222221111111111110000000000
0000000000001111111111111111111111111111111111111111111111111111111211111111111111111111100000000000
0000000000000011111111111111111111111111111111111111111111111111111111111111111111111110000000000000
0000000000000000111111111111111111111111111111111111111111111111111111111111111111111000000000000000

Julia Set with c = -54 + 83i (scaled by 100)


+++ CURRENT OUTPUT +++
0000000000000000011111111111111111111111111111111111111111111111111111111111111111110000000000000000
0000000000000001111111111111111111111111111111111111111111111111111111111111111111111100000000000000
0000000000000111111111111111111111111111111111111111111111111111111111111111111111111111000000000000
0000000000001111111111111111111111111111111111111111111111111111111111111111111111111111100000000000
0000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000
0000000001222222222222222221111111111111111111111111111111111111111111111111111111111111111100000000
0000000222222222222222222222221111111111111111111111111111111111111111111111111111111111111111000000
0000002222222222222222222222222221111111111111111111111111111111111111111111111111111111111111100000
0000022222222222222222222233333333311111111111111111111111111111111111111111111111111111111111110000
0000222222222222222222233333333344441111111111111111111111111111111111111111111111111111111111111000
0000333455222222222223333333333345543111111111111111111111111111111111111111111111111111111111111000
0003334644432222222233333463333333333311111111111111111111111111111111111111111111111111111111111100
0044333333332222222233444575433333333331111111111111111111111111111111111111111111111111111111111110
0033333333322222222224444444433333333332111111111111111111111111111111111111111111111111111111111110
0122222222222222222222255444333333333222111111111111111111111111111111111111111111111111111111111111
0112222222222222222222222233333333322222111111111111111111111111111111111111111111111111111111111111
0111222222222222222222222222222222222222111111111111111111111111111111111111111111111111111111111111
0111122222222222222222222222222222222221111111111111111111111111111111122222222222222221111111111111
1111112222222222222222222222222222222111111111111111111111111111111222222222222222222222222111111111
1111111112222222222222222222222222211111111111111111111111111111122222222222222222222222222221111111
0111111111112222222222222222222211111111111111111111111111111112222222222222222222222222222222211111
0111111111111111111222222111111111111111111111111111111111111122222222222222222222222222222222222111
0111111111111111111111111111111111111111111111111111111111111222222222322222222222222222222222222211
0111111111111111111111111111111111111111111111111111111111111222333333333344522222222222222222222221
0011111111111111111111111111111111111111111111111111111111111223333333334444544222222222222233333220
0011111111111111111111111111111111111111111111111111111111111133333333344465444422222222223333333330
0001111111111111111111111111111111111111111111111111111111111133333333334555443332222222233445533500
0001111111111111111111111111111111111111111111111111111111111113336333333333333322222222224444433300
0000111111111111111111111111111111111111111111111111111111111111446543333333333222222222222223333000
0000011111111111111111111111111111111111111111111111111111111111164433333333322222222222222222220000
0000001111111111111111111111111111111111111111111111111111111111111223333222222222222222222222200000
0000000111111111111111111111111111111111111111111111111111111111111112222222222222222222222222000000
0000000011111111111111111111111111111111111111111111111111111111111111112222222222222222222210000000
0000000001111111111111111111111111111111111111111111111111111111111111111111222222222222211100000000
0000000000011111111111111111111111111111111111111111111111111111111111111111111111111111110000000000
0000000000001111111111111111111111111111111111111111111111111111111111111111111111111111100000000000
0000000000000011111111111111111111111111111111111111111111111111111111111111111111111110000000000000
0000000000000000111111111111111111111111111111111111111111111111111111111111111111111000000000000000

Julia Set with c = -161 + 155i (scaled by 100)


--------------------------------------------------------------------------------
FILE: 25 test pointer arithmetic.lj
TYPE: SOURCE
--------------------------------------------------------------------------------
>>> SOURCE FILE MODIFIED
Previous hash: b3e4766ed56175123231fd48f9681d09
Current hash:  2a2ec9642d02931307abecaf34d32c86

--- PREVIOUS OUTPUT ---
=== Array Pointer Arithmetic Tests ===
Test 1: Basic Array Element Pointer

arr[0] = 10
ptr\\i = 10
[PASS] assertEqual: 10 == 10
After ptr\\i = 100:
arr[0] = 100
[PASS] assertEqual: 100 == 100

Test 2: Pointer to Middle Element

ptr\\i (arr[2]) = 30
[PASS] assertEqual: 30 == 30
After ptr\\i = 333:
arr[2] = 333
[PASS] assertEqual: 333 == 333

Test 3: Pointer Arithmetic (Forward)

Forward traversal using pointer arithmetic:
ptr\\i = 100
ptr\\i = 20
ptr\\i = 333
ptr\\i = 40
ptr\\i = 50

Test 4: Pointer Arithmetic (Backward)

Backward traversal using pointer arithmetic:
ptr\\i = 50
ptr\\i = 40
ptr\\i = 333
ptr\\i = 20
ptr\\i = 100

Test 5: Modify Array via Pointer Arithmetic

After doubling all values:
arr[0] = 200
arr[1] = 40
arr[2] = 666
arr[3] = 80
arr[4] = 100
[PASS] assertEqual: 200 == 200
[PASS] assertEqual: 40 == 40
[PASS] assertEqual: 666 == 666
[PASS] assertEqual: 80 == 80
[PASS] assertEqual: 100 == 100

Test 6: Float Array Pointers

Float array via pointer:
fptr\\f = 1.100
fptr\\f = 2.200
fptr\\f = 3.300
[PASS] assertFloatEqual: 1.100 ~= 1.100 (tol=0.000)
[PASS] assertFloatEqual: 2.200 ~= 2.200 (tol=0.000)
[PASS] assertFloatEqual: 3.300 ~= 3.300 (tol=0.000)

Test 7: String Array Pointers

String array via pointer:
sptr\\s = First
sptr\\s = Second
sptr\\s = Third
[PASS] assertStringEqual: "First" == "First"
[PASS] assertStringEqual: "Second" == "Second"
[PASS] assertStringEqual: "Third" == "Third"

Test 8: Pointer with Offset

ptr\\i (arr[1]) = 40
[PASS] assertEqual: 40 == 40
ptr+2 -> \\i (arr[3]) = 80
[PASS] assertEqual: 80 == 80

=== Array Pointer Arithmetic Tests Complete ===
  - Integer array pointers: PASSED
  - Float array pointers: PASSED
  - String array pointers: PASSED
  - Pointer arithmetic (forward/backward): PASSED
  - Array modification via pointers: PASSED
  - Pointer offset calculations: PASSED



+++ CURRENT OUTPUT +++
=== Array Pointer Arithmetic Tests ===
Test 1: Basic Array Element Pointer

nums[0] = 10
ptr\\i = 10
[PASS] assertEqual: 10 == 10
After ptr\\i = 100:
nums[0] = 100
[PASS] assertEqual: 100 == 100

Test 2: Pointer to Middle Element

ptr\\i (nums[2]) = 30
[PASS] assertEqual: 30 == 30
After ptr\\i = 333:
nums[2] = 333
[PASS] assertEqual: 333 == 333

Test 3: Pointer Arithmetic (Forward)

Forward traversal using pointer arithmetic:
ptr\\i = 100
ptr\\i = 20
ptr\\i = 333
ptr\\i = 40
ptr\\i = 50

Test 4: Pointer Arithmetic (Backward)

Backward traversal using pointer arithmetic:
ptr\\i = 50
ptr\\i = 40
ptr\\i = 333
ptr\\i = 20
ptr\\i = 100

Test 5: Modify Array via Pointer Arithmetic

After doubling all values:
nums[0] = 200
nums[1] = 40
nums[2] = 666
nums[3] = 80
nums[4] = 100
[PASS] assertEqual: 200 == 200
[PASS] assertEqual: 40 == 40
[PASS] assertEqual: 666 == 666
[PASS] assertEqual: 80 == 80
[PASS] assertEqual: 100 == 100

Test 6: Float Array Pointers

Float array via pointer:
fptr\\f = 1.100
fptr\\f = 2.200
fptr\\f = 3.300
[PASS] assertFloatEqual: 1.100 ~= 1.100 (tol=0.000)
[PASS] assertFloatEqual: 2.200 ~= 2.200 (tol=0.000)
[PASS] assertFloatEqual: 3.300 ~= 3.300 (tol=0.000)

Test 7: String Array Pointers

String array via pointer:
sptr\\s = First
sptr\\s = Second
sptr\\s = Third
[PASS] assertStringEqual: "First" == "First"
[PASS] assertStringEqual: "Second" == "Second"
[PASS] assertStringEqual: "Third" == "Third"

Test 8: Pointer with Offset

ptr\\i (nums[1]) = 40
[PASS] assertEqual: 40 == 40
ptr+2 -> \\i (nums[3]) = 80
[PASS] assertEqual: 80 == 80

=== Array Pointer Arithmetic Tests Complete ===
  - Integer array pointers: PASSED
  - Float array pointers: PASSED
  - String array pointers: PASSED
  - Pointer arithmetic (forward/backward): PASSED
  - Array modification via pointers: PASSED
  - Pointer offset calculations: PASSED



--------------------------------------------------------------------------------
FILE: 28 test pointers comprehensive.lj
TYPE: SOURCE
--------------------------------------------------------------------------------
>>> SOURCE FILE MODIFIED
Previous hash: 1ee63d7f5fd4a7824c0bd585faee7933
Current hash:  e53b8e15bbb9b39225a9f47ff6acff07

--- PREVIOUS OUTPUT ---
=== Comprehensive Pointer Test ===
Test 1: Swap Function
Before swap: x = 10, y = 20
After swap: x = 20, y = 10
[PASS] assertEqual: 20 == 20
[PASS] assertEqual: 10 == 10
Test 2: Array Operations
Original array: 
50 
20 
80 
10 
40 

Minimum value: 10
[PASS] assertEqual: 10 == 10
Reversed array: 
40 
10 
80 
20 
50 

[PASS] assertEqual: 40 == 40
[PASS] assertEqual: 10 == 10
[PASS] assertEqual: 80 == 80
[PASS] assertEqual: 20 == 20
[PASS] assertEqual: 50 == 50
Test 3: Pointer-Based Data Structure
Traversing pointer structure: 
100
 -> 
200
 -> 
300
 -> 
400

[PASS] assertEqual: 100 == 100
[PASS] assertEqual: 200 == 200
[PASS] assertEqual: 300 == 300
[PASS] assertEqual: 400 == 400
After modification: 
111 -> 200 -> 333 -> 400
[PASS] assertEqual: 111 == 111
[PASS] assertEqual: 200 == 200
[PASS] assertEqual: 333 == 333
[PASS] assertEqual: 400 == 400
Test 4: Pointer Indirection
value = 42
ptr1\\i = 42
[PASS] assertEqual: 42 == 42
After ptr1\\i = 99, value = 99
[PASS] assertEqual: 99 == 99

=== All Comprehensive Tests Complete ===
  - Swap function: PASSED
  - Array minimum: PASSED
  - Array reversal: PASSED
  - Pointer structures: PASSED
  - Pointer indirection: PASSED

Pointers are working correctly!



+++ CURRENT OUTPUT +++
=== Comprehensive Pointer Test ===
Test 1: Swap Function
Before swap: x = 10, y = 20
After swap: x = 20, y = 10
[PASS] assertEqual: 20 == 20
[PASS] assertEqual: 10 == 10
Test 2: Array Operations
Original array: 
50 
20 
80 
10 
40 

Minimum value: 10
[PASS] assertEqual: 10 == 10
Reversed array: 
40 
10 
80 
20 
50 

[PASS] assertEqual: 40 == 40
[PASS] assertEqual: 10 == 10
[PASS] assertEqual: 80 == 80
[PASS] assertEqual: 20 == 20
[PASS] assertEqual: 50 == 50
Test 3: Pointer-Based Data Structure
Traversing pointer structure: 
100
 -> 
200
 -> 
300
 -> 
400

[PASS] assertEqual: 100 == 100
[PASS] assertEqual: 200 == 200
[PASS] assertEqual: 300 == 300
[PASS] assertEqual: 400 == 400
After modification: 
111 -> 200 -> 333 -> 400
[PASS] assertEqual: 111 == 111
[PASS] assertEqual: 200 == 200
[PASS] assertEqual: 333 == 333
[PASS] assertEqual: 400 == 400
Test 4: Pointer Indirection
value = 42
ptr1\\i = 42
[PASS] assertEqual: 42 == 42
After ptr1\\i = 99, value = 99
[PASS] assertEqual: 99 == 99

=== All Comprehensive Tests Complete ===
  - Swap function: PASSED
  - Array minimum: PASSED
  - Array reversal: PASSED
  - Pointer structures: PASSED
  - Pointer indirection: PASSED

Pointers are working correctly!



--------------------------------------------------------------------------------
FILE: 38 test struct arrays.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
=== STRUCT ARRAYS TEST (V1.022.0) ===

TEST 1: Basic struct with integer array
---------------------------------------
  c1\\id = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  c1\\data[0] = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  c1\\data[2] = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  c1\\data[4] = 50 (expected 50)
[PASS] assertEqual: 50 == 50
  c1\\
ame = Test1 (expected Test1)
[PASS] assertStringEqual: "Test1" == "Test1"
  PASS: Basic struct with int array works!

TEST 2: Modify array elements in struct
---------------------------------------
  After modification:
  c1\\data[0] = 111 (expected 111)
[PASS] assertEqual: 111 == 111
  c1\\data[1] = 20 (expected 20, unchanged)
[PASS] assertEqual: 20 == 20
  c1\\data[2] = 333 (expected 333)
[PASS] assertEqual: 333 == 333
  c1\\data[4] = 555 (expected 555)
[PASS] assertEqual: 555 == 555
  PASS: Modifying struct array elements works!

TEST 3: Loop through struct array
---------------------------------
  Sum of c1\\data elements = 1059 (expected 1042)
[PASS] assertEqual: 1059 == 1059
  PASS: Looping through struct array works!

TEST 4: Struct with float array
-------------------------------
  v1\\
ame = Point1 (expected Point1)
[PASS] assertStringEqual: "Point1" == "Point1"
  v1\\coords[0] = 10 (expected 1.5)
[PASS] assertFloatEqual: 1.500 ~= 1.500 (tol=0.000)
  v1\\coords[1] = 10 (expected 2.5)
[PASS] assertFloatEqual: 2.500 ~= 2.500 (tol=0.000)
  v1\\coords[2] = 10 (expected 3.5)
[PASS] assertFloatEqual: 3.500 ~= 3.500 (tol=0.000)
  PASS: Struct with float array works!

TEST 5: Struct with string array
--------------------------------
  sl\\count = 3 (expected 3)
[PASS] assertEqual: 3 == 3
  sl\\items[0] = 3 (expected Apple)
[PASS] assertStringEqual: "Apple" == "Apple"
  sl\\items[1] = 10 (expected Banana)
[PASS] assertStringEqual: "Banana" == "Banana"
  sl\\items[2] = 10 (expected Cherry)
[PASS] assertStringEqual: "Cherry" == "Cherry"
  After sl\\items[1] = 'Blueberry':
  sl\\items[1] = 10 (expected Blueberry)
[PASS] assertStringEqual: "Blueberry" == "Blueberry"
  PASS: Struct with string array works!

TEST 6: Multiple array fields in struct
---------------------------------------
  ma\\header = 1 (expected 1)
[PASS] assertEqual: 1 == 1
  ma\\ints[0] = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  ma\\ints[1] = 20 (expected 20)
[PASS] assertEqual: 20 == 20
  ma\\floats[0] = 20 (expected 1.1)
[PASS] assertFloatEqual: 1.100 ~= 1.100 (tol=0.000)
  ma\\floats[1] = 10 (expected 2.2)
[PASS] assertFloatEqual: 2.200 ~= 2.200 (tol=0.000)
  ma\\	railer = 99 (expected 99)
[PASS] assertEqual: 99 == 99
  PASS: Multiple array fields work!

TEST 7: Variable index access
-----------------------------
  c1\\data[idx] where idx=2: 333 (expected 333)
[PASS] assertEqual: 333 == 333
  c1\\data[idx] where idx=0: 111 (expected 111)
[PASS] assertEqual: 111 == 111
  PASS: Variable index access works!

=== ALL STRUCT ARRAY TESTS PASSED ===

Summary:
  - Struct definition with array fields: WORKING
  - Struct initialization with array values: WORKING
  - Array element access (s\\arr[i]): WORKING
  - Array element modification: WORKING
  - Loop iteration through struct arrays: WORKING
  - Float array fields: WORKING
  - String array fields: WORKING
  - Multiple array fields: WORKING
  - Variable index access: WORKING



+++ CURRENT OUTPUT +++
=== STRUCT ARRAYS TEST (V1.022.0) ===

TEST 1: Basic struct with integer array
---------------------------------------
  c1\\id = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  c1\\data[0] = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  c1\\data[2] = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  c1\\data[4] = 50 (expected 50)
[PASS] assertEqual: 50 == 50
  c1\\name = Test1 (expected Test1)
[PASS] assertStringEqual: "Test1" == "Test1"
  PASS: Basic struct with int array works!

TEST 2: Modify array elements in struct
---------------------------------------
  After modification:
  c1\\data[0] = 111 (expected 111)
[PASS] assertEqual: 111 == 111
  c1\\data[1] = 20 (expected 20, unchanged)
[PASS] assertEqual: 20 == 20
  c1\\data[2] = 333 (expected 333)
[PASS] assertEqual: 333 == 333
  c1\\data[4] = 555 (expected 555)
[PASS] assertEqual: 555 == 555
  PASS: Modifying struct array elements works!

TEST 3: Loop through struct array
---------------------------------
  Sum of c1\\data elements = 1059 (expected 1042)
[PASS] assertEqual: 1059 == 1059
  PASS: Looping through struct array works!

TEST 4: Struct with float array
-------------------------------
  v1\\name = Point1 (expected Point1)
[PASS] assertStringEqual: "Point1" == "Point1"
  v1\\coords[0] = 10 (expected 1.5)
[PASS] assertFloatEqual: 1.500 ~= 1.500 (tol=0.000)
  v1\\coords[1] = 10 (expected 2.5)
[PASS] assertFloatEqual: 2.500 ~= 2.500 (tol=0.000)
  v1\\coords[2] = 10 (expected 3.5)
[PASS] assertFloatEqual: 3.500 ~= 3.500 (tol=0.000)
  PASS: Struct with float array works!

TEST 5: Struct with string array
--------------------------------
  sl\\count = 3 (expected 3)
[PASS] assertEqual: 3 == 3
  sl\\items[0] = 3 (expected Apple)
[PASS] assertStringEqual: "Apple" == "Apple"
  sl\\items[1] = 10 (expected Banana)
[PASS] assertStringEqual: "Banana" == "Banana"
  sl\\items[2] = 10 (expected Cherry)
[PASS] assertStringEqual: "Cherry" == "Cherry"
  After sl\\items[1] = 'Blueberry':
  sl\\items[1] = 10 (expected Blueberry)
[PASS] assertStringEqual: "Blueberry" == "Blueberry"
  PASS: Struct with string array works!

TEST 6: Multiple array fields in struct
---------------------------------------
  ma\\header = 1 (expected 1)
[PASS] assertEqual: 1 == 1
  ma\\ints[0] = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  ma\\ints[1] = 20 (expected 20)
[PASS] assertEqual: 20 == 20
  ma\\floats[0] = 20 (expected 1.1)
[PASS] assertFloatEqual: 1.100 ~= 1.100 (tol=0.000)
  ma\\floats[1] = 10 (expected 2.2)
[PASS] assertFloatEqual: 2.200 ~= 2.200 (tol=0.000)
  ma\\trailer = 99 (expected 99)
[PASS] assertEqual: 99 == 99
  PASS: Multiple array fields work!

TEST 7: Variable index access
-----------------------------
  c1\\data[idx] where idx=2: 333 (expected 333)
[PASS] assertEqual: 333 == 333
  c1\\data[idx] where idx=0: 111 (expected 111)
[PASS] assertEqual: 111 == 111
  PASS: Variable index access works!

=== ALL STRUCT ARRAY TESTS PASSED ===

Summary:
  - Struct definition with array fields: WORKING
  - Struct initialization with array values: WORKING
  - Array element access (s\\arr[i]): WORKING
  - Array element modification: WORKING
  - Loop iteration through struct arrays: WORKING
  - Float array fields: WORKING
  - String array fields: WORKING
  - Multiple array fields: WORKING
  - Variable index access: WORKING



--------------------------------------------------------------------------------
FILE: 40 test float functions.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
=== Float Function Diagnostics ===

Test 1: Pass float literal 3.14
  Inside testFloatParam: x = 3.1400
  Returned: 3.1400

Test 2: Pass float variable
  myFloat = 2.5000
  Inside testFloatParam: x = 2.5000
  Returned: 2.5000

Test 3: Pass integer as float param
  myInt = 7
  Inside testFloatParam: x = 7.0000
  Returned: 7.0000

Test 4: Add two floats (10.5 + 3.5)
  Inside addFloats: a=10.5000 b=3.5000 result=14.0000
  Returned: 14.0000 (expected 14.0)

Test 5: Division (10.0 / 4.0)
  Inside divideFloats: a=10.0000 b=4.0000 result=2.5000
  Returned: 2.5000 (expected 2.5)

Test 6: Division (48.0 / 2.0)
  Inside divideFloats: a=48.0000 b=2.0000 result=24.0000
  Returned: 24.0000 (expected 24.0)

Test 7: Check if 24.0 == 24
  Inside isEqual24: val=24.0000
    val == 24.0 is TRUE
  isEqual24(24.0) returned: 1

Test 8: Check calculated 24
  calc = 6.0 * 4.0 = 24.0000
  Inside isEqual24: val=24.0000
    val == 24.0 is TRUE
  isEqual24(calc) returned: 1

Test 9: isNear24 with 24.0
  Inside isNear24: val=24.0000 diff=0.0000
    diff < 0.01 is TRUE
  isNear24(24.0) returned: 1

Test 10: isNear24 with calculated value
  calc2 = 8.0 * 3.0 = 24.0000
  Inside isNear24: val=24.0000 diff=0.0000
    diff < 0.01 is TRUE
  isNear24(calc2) returned: 1

Test 11: Integer array element to float
  nums = [1, 2, 3, 4]
  product = 24.0000 (expected 24.0)
  Inside isNear24: val=24.0000 diff=0.0000
    diff < 0.01 is TRUE
  isNear24(product) returned: 1

Test 12: Chain ((1 + 2) + 3) * 4
  step1 = 1.0 + 2.0 = 3.0000
  step2 = step1 + 3.0 = 6.0000
  step3 = step2 * 4.0 = 24.0000
  Inside isNear24: val=24.0000 diff=0.0000
    diff < 0.01 is TRUE
  isNear24(step3) returned: 1

=== Diagnostics Complete ===


--------------------------------------------------------------------------------
FILE: 41 test string array.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
=== String Array Test ===

Direct access:
  ops[0] = '+'
  ops[1] = '-'
  ops[2] = '*'
  ops[3] = '/'

Loop access:
  ops[0] = '+'
  ops[1] = '-'
  ops[2] = '*'
  ops[3] = '/'

Character verification:
  ops[0] should be '+': +
  ops[1] should be '-': -
  ops[2] should be '*': *
  ops[3] should be '/': /

Expression test (1 + 2 = + pattern):
1+ 2 = 3

=== Test Complete ===


--------------------------------------------------------------------------------
FILE: 42 test array of structs.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
=== ARRAY OF STRUCTS TEST (V1.022.44) ===

TEST 1: Basic array of structs declaration
------------------------------------------
  Declared: array points.Point[5]
  PASS: Declaration compiled!

TEST 2: Assign to struct array elements
---------------------------------------
  Assigned: points[0] = (10, 20)
  Assigned: points[1] = (30, 40)
  Assigned: points[2] = (50, 60)
  PASS: Assignments compiled!

TEST 3: Read from struct array elements
--------------------------------------
  points[0]\\x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  points[0]\\y = 20 (expected 20)
[PASS] assertEqual: 20 == 20
  points[1]\\x = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  points[1]\\y = 40 (expected 40)
[PASS] assertEqual: 40 == 40
  points[2]\\x = 50 (expected 50)
[PASS] assertEqual: 50 == 50
  points[2]\\y = 60 (expected 60)
[PASS] assertEqual: 60 == 60
  PASS: All reads match expected values!

TEST 4: Loop through array of structs
------------------------------------
  points[0] = (10, 20)
  points[1] = (30, 40)
  points[2] = (50, 60)
  points[3] = (70, 80)
  points[4] = (90, 100)
  Sum of x values = 250 (expected 250)
[PASS] assertEqual: 250 == 250
  Sum of y values = 300 (expected 300)
[PASS] assertEqual: 300 == 300
  PASS: Loop iteration works!

TEST 5: Array of structs with float fields
-----------------------------------------
  particles[0]\\posX = 1.500 (expected 1.5)
[PASS] assertFloatEqual: 1.500 ~= 1.500 (tol=0.000)
  particles[1]\\posY = 4.500 (expected 4.5)
[PASS] assertFloatEqual: 4.500 ~= 4.500 (tol=0.000)
  particles[2]\\name = P2 (expected P2)
[PASS] assertStringEqual: "P2" == "P2"
  PASS: Float and string fields work!

TEST 6: Variable index access
----------------------------
  points[idx]\\x where idx=1: 30 (expected 30)
[PASS] assertEqual: 30 == 30
  points[idx]\\y where idx=3: 80 (expected 80)
[PASS] assertEqual: 80 == 80
  PASS: Variable index works!

TEST 7: Expressions with struct array fields
-------------------------------------------
  Distance x (p4-p0) = 80 (expected 80)
[PASS] assertEqual: 80 == 80
  Mid-point x = 50 (expected 50)
[PASS] assertEqual: 50 == 50
  PASS: Expressions work!

TEST 8: Mixed type struct array
------------------------------
  records[0] = (1, 10.500, 'First')
  records[1] = (2, 20.500, 'Second')
  records[2] = (3, 30.500, 'Third')
[PASS] assertEqual: 2 == 2
[PASS] assertFloatEqual: 30.500 ~= 30.500 (tol=0.000)
[PASS] assertStringEqual: "First" == "First"
  PASS: Mixed type struct arrays work!

=== ALL ARRAY OF STRUCTS TESTS PASSED ===

Summary:
  - Array of structs declaration: WORKING
  - Field assignment (arr[i]\\field = val): WORKING
  - Field read (arr[i]\\field): WORKING
  - Loop iteration: WORKING
  - Float fields: WORKING
  - String fields: WORKING
  - Variable index: WORKING
  - Expressions: WORKING



--------------------------------------------------------------------------------
FILE: 43 test nested structures.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
=== NESTED STRUCTURES TEST (V1.022.50) ===

TEST 1: Basic nested structure
------------------------------
  rect\\pos\\x = 1 (expected 10)
[FAIL] assertEqual: expected 10 but got 1
  rect\\pos\\y = 2 (expected 20)
[FAIL] assertEqual: expected 20 but got 2
  rect\\size\\width = 3 (expected 100)
[FAIL] assertEqual: expected 100 but got 3
  rect\\size\\height = 4 (expected 50)
[FAIL] assertEqual: expected 50 but got 4
  rect\\
ame = TestRect (expected TestRect)
[PASS] assertStringEqual: "TestRect" == "TestRect"
  PASS: Basic nested structure works!

TEST 2: Multiple nested structures
---------------------------------
  win\\	opLeft\\x = 0 (expected 0)
[PASS] assertEqual: 0 == 0
  win\\bottomRight\\x = 800 (expected 800)
[PASS] assertEqual: 800 == 800
  win\\bottomRight\\y = 600 (expected 600)
[PASS] assertEqual: 600 == 600
  win\\background\\ = 255 (expected 255)
[PASS] assertEqual: 255 == 255
  win\\background\\g = 128 (expected 128)
[PASS] assertEqual: 128 == 128
  win\\background\\b = 64 (expected 64)
[PASS] assertEqual: 64 == 64
  win\\	itle = Main Window (expected Main Window)
[PASS] assertStringEqual: "Main Window" == "Main Window"
  PASS: Multiple nested structures work!

TEST 3: Expressions with nested fields
-------------------------------------
  Rectangle area = 12 (expected 5000)
[FAIL] assertEqual: expected 5000 but got 12
  Window width = 800 (expected 800)
[PASS] assertEqual: 800 == 800
  Window height = 600 (expected 600)
[PASS] assertEqual: 600 == 600
  Color sum (R+G+B) = 447 (expected 447)
[PASS] assertEqual: 447 == 447
  PASS: Expressions with nested fields work!

TEST 4: Assignment from expressions
----------------------------------
  rect2\\pos\\x = 51 (expected 60)
[FAIL] assertEqual: expected 60 but got 51
  rect2\\pos\\y = 52 (expected 70)
[FAIL] assertEqual: expected 70 but got 52
  rect2\\size\\width = 1 (expected 50)
[FAIL] assertEqual: expected 50 but got 1
  rect2\\size\\height = 2 (expected 25)
[FAIL] assertEqual: expected 25 but got 2
  PASS: Assignment from expressions works!

TEST 5: Structure total size calculation
---------------------------------------
  rect\\pos\\x = 1 (expected 1)
[PASS] assertEqual: 1 == 1
  rect\\pos\\y = 2 (expected 2)
[PASS] assertEqual: 2 == 2
  rect\\size\\width = 3 (expected 3)
[PASS] assertEqual: 3 == 3
  rect\\size\\height = 4 (expected 4)
[PASS] assertEqual: 4 == 4
  rect\\
ame = Five (expected Five)
[PASS] assertStringEqual: "Five" == "Five"
  PASS: Total size calculation correct!

TEST 6: Array of nested structures
---------------------------------
  rects[0]\\pos\\x = 0 (expected 0)
[PASS] assertEqual: 0 == 0
  rects[1]\\size\\width = 200 (expected 200)
[PASS] assertEqual: 200 == 200
  rects[2]\\
ame = Large (expected Large)
[PASS] assertStringEqual: "Large" == "Large"
  rects[0] area = 100
  rects[1] area = 30000
  rects[2] area = 480000
  Total area = 510100 (expected 510100)
[PASS] assertEqual: 510100 == 510100
  PASS: Array of nested structures works!

TEST 7: Function modifying nested structure fields
-------------------------------------------------
  Before: rects[0] pos=(0,0) size=(10x10) name=Small
  moveRect: moved rects[0] by (25, 35)
  scaleRect: scaled rects[0] by factor 3
  renameRect: renamed rects[0] to 'Modified'
  After: rects[0] pos=(25,35) size=(30x30) name=Modified
  rects[0]\\pos\\x = 25 (expected 25)
[PASS] assertEqual: 25 == 25
  rects[0]\\pos\\y = 35 (expected 35)
[PASS] assertEqual: 35 == 35
  rects[0]\\size\\width = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  rects[0]\\size\\height = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  rects[0]\\
ame = Modified (expected Modified)
[PASS] assertStringEqual: "Modified" == "Modified"
  PASS: Function modifying nested structure fields works!

=== ALL NESTED STRUCTURE TESTS PASSED ===

Summary:
  - Nested struct definition: WORKING
  - Nested field assignment (outer\\inner\\field = val): WORKING
  - Nested field read (outer\\inner\\field): WORKING
  - Multiple nested fields: WORKING
  - Expressions with nested fields: WORKING
  - Slot allocation for nested structs: WORKING
  - Array of nested structures: WORKING
  - Function modifying nested struct fields: WORKING



+++ CURRENT OUTPUT +++
=== NESTED STRUCTURES TEST (V1.022.50) ===

TEST 1: Basic nested structure
------------------------------
  rect\\pos\\x = 1 (expected 10)
[FAIL] assertEqual: expected 10 but got 1
  rect\\pos\\y = 2 (expected 20)
[FAIL] assertEqual: expected 20 but got 2
  rect\\size\\width = 3 (expected 100)
[FAIL] assertEqual: expected 100 but got 3
  rect\\size\\height = 4 (expected 50)
[FAIL] assertEqual: expected 50 but got 4
  rect\\name = TestRect (expected TestRect)
[PASS] assertStringEqual: "TestRect" == "TestRect"
  PASS: Basic nested structure works!

TEST 2: Multiple nested structures
---------------------------------
  win\\topLeft\\x = 0 (expected 0)
[PASS] assertEqual: 0 == 0
  win\\bottomRight\\x = 800 (expected 800)
[PASS] assertEqual: 800 == 800
  win\\bottomRight\\y = 600 (expected 600)
[PASS] assertEqual: 600 == 600
  win\\background\\r = 255 (expected 255)
[PASS] assertEqual: 255 == 255
  win\\background\\g = 128 (expected 128)
[PASS] assertEqual: 128 == 128
  win\\background\\b = 64 (expected 64)
[PASS] assertEqual: 64 == 64
  win\\title = Main Window (expected Main Window)
[PASS] assertStringEqual: "Main Window" == "Main Window"
  PASS: Multiple nested structures work!

TEST 3: Expressions with nested fields
-------------------------------------
  Rectangle area = 12 (expected 5000)
[FAIL] assertEqual: expected 5000 but got 12
  Window width = 800 (expected 800)
[PASS] assertEqual: 800 == 800
  Window height = 600 (expected 600)
[PASS] assertEqual: 600 == 600
  Color sum (R+G+B) = 447 (expected 447)
[PASS] assertEqual: 447 == 447
  PASS: Expressions with nested fields work!

TEST 4: Assignment from expressions
----------------------------------
  rect2\\pos\\x = 51 (expected 60)
[FAIL] assertEqual: expected 60 but got 51
  rect2\\pos\\y = 52 (expected 70)
[FAIL] assertEqual: expected 70 but got 52
  rect2\\size\\width = 1 (expected 50)
[FAIL] assertEqual: expected 50 but got 1
  rect2\\size\\height = 2 (expected 25)
[FAIL] assertEqual: expected 25 but got 2
  PASS: Assignment from expressions works!

TEST 5: Structure total size calculation
---------------------------------------
  rect\\pos\\x = 1 (expected 1)
[PASS] assertEqual: 1 == 1
  rect\\pos\\y = 2 (expected 2)
[PASS] assertEqual: 2 == 2
  rect\\size\\width = 3 (expected 3)
[PASS] assertEqual: 3 == 3
  rect\\size\\height = 4 (expected 4)
[PASS] assertEqual: 4 == 4
  rect\\name = Five (expected Five)
[PASS] assertStringEqual: "Five" == "Five"
  PASS: Total size calculation correct!

TEST 6: Array of nested structures
---------------------------------
  rects[0]\\pos\\x = 0 (expected 0)
[PASS] assertEqual: 0 == 0
  rects[1]\\size\\width = 200 (expected 200)
[PASS] assertEqual: 200 == 200
  rects[2]\\name = Large (expected Large)
[PASS] assertStringEqual: "Large" == "Large"
  rects[0] area = 100
  rects[1] area = 30000
  rects[2] area = 480000
  Total area = 510100 (expected 510100)
[PASS] assertEqual: 510100 == 510100
  PASS: Array of nested structures works!

TEST 7: Function modifying nested structure fields
-------------------------------------------------
  Before: rects[0] pos=(0,0) size=(10x10) name=Small
  moveRect: moved rects[0] by (25, 35)
  scaleRect: scaled rects[0] by factor 3
  renameRect: renamed rects[0] to 'Modified'
  After: rects[0] pos=(25,35) size=(30x30) name=Modified
  rects[0]\\pos\\x = 25 (expected 25)
[PASS] assertEqual: 25 == 25
  rects[0]\\pos\\y = 35 (expected 35)
[PASS] assertEqual: 35 == 35
  rects[0]\\size\\width = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  rects[0]\\size\\height = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  rects[0]\\name = Modified (expected Modified)
[PASS] assertStringEqual: "Modified" == "Modified"
  PASS: Function modifying nested structure fields works!

=== ALL NESTED STRUCTURE TESTS PASSED ===

Summary:
  - Nested struct definition: WORKING
  - Nested field assignment (outer\\inner\\field = val): WORKING
  - Nested field read (outer\\inner\\field): WORKING
  - Multiple nested fields: WORKING
  - Expressions with nested fields: WORKING
  - Slot allocation for nested structs: WORKING
  - Array of nested structures: WORKING
  - Function modifying nested struct fields: WORKING



--------------------------------------------------------------------------------
FILE: 44 test struct pointers.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
=== STRUCT POINTERS TEST (V1.022.55) ===

TEST 1: Basic struct access (reference)
---------------------------------------
  p.x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  p.y = 30 (expected 20)
[FAIL] assertEqual: expected 20 but got 30
  PASS: Basic struct access works

TEST 2: Address-of struct
------------------------
  ptr = &p (pointer to struct assigned)
  ptr\\x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  ptr\\y = 30 (expected 20)
[FAIL] assertEqual: expected 20 but got 30
  PASS: Struct pointer read works!

TEST 3: Write through struct pointer
------------------------------------
  ptr\\x = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  ptr\\y = 200 (expected 200)
[PASS] assertEqual: 200 == 200
  p\\x = 100 (expected 100 - modified through ptr)
[PASS] assertEqual: 100 == 100
  p\\y = 200 (expected 200 - modified through ptr)
[PASS] assertEqual: 200 == 200
  PASS: Struct pointer write works!

TEST 4: Rectangle with string field
-----------------------------------
  rptr\\x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  rptr\\width = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  rptr\\
ame = 100 (expected TestRect)
[PASS] assertStringEqual: "TestRect" == "TestRect"
  After modify: rptr\\width = 200 (expected 200)
[PASS] assertEqual: 200 == 200
  After modify: rect\\height = 150 (expected 150)
[PASS] assertEqual: 150 == 150
  After modify: rect\\
ame = ModifiedRect (expected ModifiedRect)
[PASS] assertStringEqual: "ModifiedRect" == "ModifiedRect"
  PASS: Rectangle pointer works!

TEST 5: Mixed types struct pointer
---------------------------------
  mptr\\intVal = 42 (expected 42)
[PASS] assertEqual: 42 == 42
  mptr\\floatVal = 42 (expected ~3.14)
[PASS] assertFloatEqual: 3.142 ~= 3.142 (tol=0.000)
  mptr\\strVal = 10 (expected Hello)
[PASS] assertStringEqual: "Hello" == "Hello"
  After modify: mix\\intVal = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  After modify: mix\\floatVal = 2.718 (expected ~2.72)
[PASS] assertFloatEqual: 2.718 ~= 2.718 (tol=0.000)
  After modify: mix\\strVal = World (expected World)
[PASS] assertStringEqual: "World" == "World"
  PASS: Mixed types struct pointer works!

TEST 6: Expressions with pointer fields
--------------------------------------
  sum = ptr\\x + ptr\\y = 80 (expected 80)
[PASS] assertEqual: 80 == 80
  diff = ptr\\x - ptr\\y = 20 (expected 20)
[PASS] assertEqual: 20 == 20
  prod = ptr\\x * ptr\\y = 1500 (expected 1500)
[PASS] assertEqual: 1500 == 1500
  PASS: Expressions with pointer fields work!

TEST 7: Multiple pointers
------------------------
  ptr1\\x = 1, ptr1\\y = 2 (expected 1, 2)
[PASS] assertEqual: 1 == 1
[PASS] assertEqual: 2 == 2
  ptr2\\x = 3, ptr2\\y = 4 (expected 3, 4)
[PASS] assertEqual: 3 == 3
[PASS] assertEqual: 4 == 4
  After swap: ptr1\\x = 3 (expected 3)
[PASS] assertEqual: 3 == 3
  After swap: ptr2\\x = 1 (expected 1)
[PASS] assertEqual: 1 == 1
  PASS: Multiple pointers work!

=== ALL STRUCT POINTER TESTS PASSED ===

Summary:
  - Address-of struct (&struct): WORKING
  - Pointer field read (ptr\\field): WORKING
  - Pointer field write (ptr\\field = val): WORKING
  - Integer fields: WORKING
  - Float fields: WORKING
  - String fields: WORKING
  - Expressions with pointer fields: WORKING
  - Multiple pointers: WORKING



+++ CURRENT OUTPUT +++
=== STRUCT POINTERS TEST (V1.022.55) ===

TEST 1: Basic struct access (reference)
---------------------------------------
  p.x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  p.y = 30 (expected 20)
[FAIL] assertEqual: expected 20 but got 30
  PASS: Basic struct access works

TEST 2: Address-of struct
------------------------
  ptr = &p (pointer to struct assigned)
  ptr\\x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  ptr\\y = 30 (expected 20)
[FAIL] assertEqual: expected 20 but got 30
  PASS: Struct pointer read works!

TEST 3: Write through struct pointer
------------------------------------
  ptr\\x = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  ptr\\y = 200 (expected 200)
[PASS] assertEqual: 200 == 200
  p\\x = 100 (expected 100 - modified through ptr)
[PASS] assertEqual: 100 == 100
  p\\y = 200 (expected 200 - modified through ptr)
[PASS] assertEqual: 200 == 200
  PASS: Struct pointer write works!

TEST 4: Rectangle with string field
-----------------------------------
  rptr\\x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  rptr\\width = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  rptr\\name = 100 (expected TestRect)
[PASS] assertStringEqual: "TestRect" == "TestRect"
  After modify: rptr\\width = 200 (expected 200)
[PASS] assertEqual: 200 == 200
  After modify: rect\\height = 150 (expected 150)
[PASS] assertEqual: 150 == 150
  After modify: rect\\name = ModifiedRect (expected ModifiedRect)
[PASS] assertStringEqual: "ModifiedRect" == "ModifiedRect"
  PASS: Rectangle pointer works!

TEST 5: Mixed types struct pointer
---------------------------------
  mptr\\intVal = 42 (expected 42)
[PASS] assertEqual: 42 == 42
  mptr\\floatVal = 42 (expected ~3.14)
[PASS] assertFloatEqual: 3.142 ~= 3.142 (tol=0.000)
  mptr\\strVal = 10 (expected Hello)
[PASS] assertStringEqual: "Hello" == "Hello"
  After modify: mix\\intVal = 100 (expected 100)
[PASS] assertEqual: 100 == 100
  After modify: mix\\floatVal = 2.718 (expected ~2.72)
[PASS] assertFloatEqual: 2.718 ~= 2.718 (tol=0.000)
  After modify: mix\\strVal = World (expected World)
[PASS] assertStringEqual: "World" == "World"
  PASS: Mixed types struct pointer works!

TEST 6: Expressions with pointer fields
--------------------------------------
  sum = ptr\\x + ptr\\y = 80 (expected 80)
[PASS] assertEqual: 80 == 80
  diff = ptr\\x - ptr\\y = 20 (expected 20)
[PASS] assertEqual: 20 == 20
  prod = ptr\\x * ptr\\y = 1500 (expected 1500)
[PASS] assertEqual: 1500 == 1500
  PASS: Expressions with pointer fields work!

TEST 7: Multiple pointers
------------------------
  ptr1\\x = 1, ptr1\\y = 2 (expected 1, 2)
[PASS] assertEqual: 1 == 1
[PASS] assertEqual: 2 == 2
  ptr2\\x = 3, ptr2\\y = 4 (expected 3, 4)
[PASS] assertEqual: 3 == 3
[PASS] assertEqual: 4 == 4
  After swap: ptr1\\x = 3 (expected 3)
[PASS] assertEqual: 3 == 3
  After swap: ptr2\\x = 1 (expected 1)
[PASS] assertEqual: 1 == 1
  PASS: Multiple pointers work!

=== ALL STRUCT POINTER TESTS PASSED ===

Summary:
  - Address-of struct (&struct): WORKING
  - Pointer field read (ptr\\field): WORKING
  - Pointer field write (ptr\\field = val): WORKING
  - Integer fields: WORKING
  - Float fields: WORKING
  - String fields: WORKING
  - Expressions with pointer fields: WORKING
  - Multiple pointers: WORKING



--------------------------------------------------------------------------------
FILE: 45 test struct copy.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
=== STRUCT COPY TEST (V1.022.65) ===

TEST 1: Basic Point struct copy
-------------------------------
  Before copy:
    p1 = (10, 20)
    p2 = (100, 200)
  After p2 = p1:
    p1 = (10, 20)
    p2 = (10, 20)
[PASS] assertEqual: 10 == 10
[PASS] assertEqual: 20 == 20
[PASS] assertEqual: 10 == 10
[PASS] assertEqual: 20 == 20
  PASS: Basic struct copy works!

TEST 2: Copy independence
------------------------
  After modifying p2:
    p1 = (10, 20) - should be unchanged
    p2 = (100, 200) - should be modified
[PASS] assertEqual: 10 == 10
[PASS] assertEqual: 20 == 20
[PASS] assertEqual: 100 == 100
[PASS] assertEqual: 200 == 200
  PASS: Copy is independent of original!

TEST 3: Rectangle struct copy
----------------------------
  Before copy:
    rect1 = (5, 10, 100, 50)
    rect2 = (0, 0, 0, 0)
  After rect2 = rect1:
    rect2 = (5, 10, 100, 50)
[PASS] assertEqual: 5 == 5
[PASS] assertEqual: 10 == 10
[PASS] assertEqual: 100 == 100
[PASS] assertEqual: 50 == 50
  PASS: Rectangle struct copy works!

TEST 4: Mixed types struct copy
------------------------------
  Before copy:
    m1 = (42, 3.142, 'Hello World')
    m2 = (0, 0.000, '')
  After m2 = m1:
    m2 = (42, 3.142, 'Hello World')
[PASS] assertEqual: 42 == 42
[PASS] assertFloatEqual: 3.142 ~= 3.142 (tol=0.000)
[PASS] assertStringEqual: "Hello World" == "Hello World"
  PASS: Mixed types struct copy works!

TEST 5: Multiple consecutive copies
----------------------------------
  Initial: pa=(1,2) pb=(3,4) pc=(5,6)
  After pb=pa, pc=pb:
    pa=(1,2) pb=(1,2) pc=(1,2)
[PASS] assertEqual: 1 == 1
[PASS] assertEqual: 2 == 2
[PASS] assertEqual: 1 == 1
[PASS] assertEqual: 2 == 2
[PASS] assertEqual: 1 == 1
[PASS] assertEqual: 2 == 2
  PASS: Multiple copies work!

TEST 6: Copy after literal initialization
-----------------------------------------
  dst = (99, 88) after copy from {99, 88}
[PASS] assertEqual: 99 == 99
[PASS] assertEqual: 88 == 88
  PASS: Copy after literal init works!

=== ALL STRUCT COPY TESTS PASSED ===

Summary:
  - Basic struct copy: WORKING
  - Copy independence: WORKING
  - Multi-field structs: WORKING
  - Mixed type fields: WORKING
  - Consecutive copies: WORKING
  - Literal init + copy: WORKING



--------------------------------------------------------------------------------
FILE: 46 test array of structs.lj
TYPE: OUTPUT
--------------------------------------------------------------------------------
>>> OUTPUT CHANGED (source unchanged - possible regression!)

--- PREVIOUS OUTPUT ---
=== ARRAY OF STRUCTS TEST (V1.022.44) ===

TEST 1: Basic array of structs declaration
------------------------------------------
  Declared: array points.Point[5]
  PASS: Declaration compiled!

TEST 2: Assign to struct array elements
---------------------------------------
  Assigned: points[0] = (10, 20)
  Assigned: points[1] = (30, 40)
  Assigned: points[2] = (50, 60)
  PASS: Assignments compiled!

TEST 3: Read from struct array elements
--------------------------------------
  points[0]\\x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  points[0]\\y = 20 (expected 20)
[PASS] assertEqual: 20 == 20
  points[1]\\x = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  points[1]\\y = 40 (expected 40)
[PASS] assertEqual: 40 == 40
  points[2]\\x = 50 (expected 50)
[PASS] assertEqual: 50 == 50
  points[2]\\y = 60 (expected 60)
[PASS] assertEqual: 60 == 60
  PASS: All reads match expected values!

TEST 4: Loop through array of structs
------------------------------------
  points[0] = (10, 20)
  points[1] = (30, 40)
  points[2] = (50, 60)
  points[3] = (70, 80)
  points[4] = (90, 100)
  Sum of x values = 250 (expected 250)
[PASS] assertEqual: 250 == 250
  Sum of y values = 300 (expected 300)
[PASS] assertEqual: 300 == 300
  PASS: Loop iteration works!

TEST 5: Array of structs with float fields
-----------------------------------------
  particles[0]\\posX = 1.500 (expected 1.5)
[PASS] assertFloatEqual: 1.500 ~= 1.500 (tol=0.000)
  particles[1]\\posY = 4.500 (expected 4.5)
[PASS] assertFloatEqual: 4.500 ~= 4.500 (tol=0.000)
  particles[2]\\
ame = P2 (expected P2)
[PASS] assertStringEqual: "P2" == "P2"
  PASS: Float and string fields work!

TEST 6: Variable index access
----------------------------
  points[idx]\\x where idx=1: 30 (expected 30)
[PASS] assertEqual: 30 == 30
  points[idx]\\y where idx=3: 80 (expected 80)
[PASS] assertEqual: 80 == 80
  PASS: Variable index works!

TEST 7: Expressions with struct array fields
-------------------------------------------
  Distance x (p4-p0) = 80 (expected 80)
[PASS] assertEqual: 80 == 80
  Mid-point x = 50 (expected 50)
[PASS] assertEqual: 50 == 50
  PASS: Expressions work!

TEST 8: Mixed type struct array
------------------------------
  records[0] = (1, 10.500, 'First')
  records[1] = (2, 20.500, 'Second')
  records[2] = (3, 30.500, 'Third')
[PASS] assertEqual: 2 == 2
[PASS] assertFloatEqual: 30.500 ~= 30.500 (tol=0.000)
[PASS] assertStringEqual: "First" == "First"
  PASS: Mixed type struct arrays work!

=== ALL ARRAY OF STRUCTS TESTS PASSED ===

Summary:
  - Array of structs declaration: WORKING
  - Field assignment (arr[i]\\field = val): WORKING
  - Field read (arr[i]\\field): WORKING
  - Loop iteration: WORKING
  - Float fields: WORKING
  - String fields: WORKING
  - Variable index: WORKING
  - Expressions: WORKING



+++ CURRENT OUTPUT +++
=== ARRAY OF STRUCTS TEST (V1.022.44) ===

TEST 1: Basic array of structs declaration
------------------------------------------
  Declared: array points.Point[5]
  PASS: Declaration compiled!

TEST 2: Assign to struct array elements
---------------------------------------
  Assigned: points[0] = (10, 20)
  Assigned: points[1] = (30, 40)
  Assigned: points[2] = (50, 60)
  PASS: Assignments compiled!

TEST 3: Read from struct array elements
--------------------------------------
  points[0]\\x = 10 (expected 10)
[PASS] assertEqual: 10 == 10
  points[0]\\y = 20 (expected 20)
[PASS] assertEqual: 20 == 20
  points[1]\\x = 30 (expected 30)
[PASS] assertEqual: 30 == 30
  points[1]\\y = 40 (expected 40)
[PASS] assertEqual: 40 == 40
  points[2]\\x = 50 (expected 50)
[PASS] assertEqual: 50 == 50
  points[2]\\y = 60 (expected 60)
[PASS] assertEqual: 60 == 60
  PASS: All reads match expected values!

TEST 4: Loop through array of structs
------------------------------------
  points[0] = (10, 20)
  points[1] = (30, 40)
  points[2] = (50, 60)
  points[3] = (70, 80)
  points[4] = (90, 100)
  Sum of x values = 250 (expected 250)
[PASS] assertEqual: 250 == 250
  Sum of y values = 300 (expected 300)
[PASS] assertEqual: 300 == 300
  PASS: Loop iteration works!

TEST 5: Array of structs with float fields
-----------------------------------------
  particles[0]\\posX = 1.500 (expected 1.5)
[PASS] assertFloatEqual: 1.500 ~= 1.500 (tol=0.000)
  particles[1]\\posY = 4.500 (expected 4.5)
[PASS] assertFloatEqual: 4.500 ~= 4.500 (tol=0.000)
  particles[2]\\name = P2 (expected P2)
[PASS] assertStringEqual: "P2" == "P2"
  PASS: Float and string fields work!

TEST 6: Variable index access
----------------------------
  points[idx]\\x where idx=1: 30 (expected 30)
[PASS] assertEqual: 30 == 30
  points[idx]\\y where idx=3: 80 (expected 80)
[PASS] assertEqual: 80 == 80
  PASS: Variable index works!

TEST 7: Expressions with struct array fields
-------------------------------------------
  Distance x (p4-p0) = 80 (expected 80)
[PASS] assertEqual: 80 == 80
  Mid-point x = 50 (expected 50)
[PASS] assertEqual: 50 == 50
  PASS: Expressions work!

TEST 8: Mixed type struct array
------------------------------
  records[0] = (1, 10.500, 'First')
  records[1] = (2, 20.500, 'Second')
  records[2] = (3, 30.500, 'Third')
[PASS] assertEqual: 2 == 2
[PASS] assertFloatEqual: 30.500 ~= 30.500 (tol=0.000)
[PASS] assertStringEqual: "First" == "First"
  PASS: Mixed type struct arrays work!

=== ALL ARRAY OF STRUCTS TESTS PASSED ===

Summary:
  - Array of structs declaration: WORKING
  - Field assignment (arr[i]\\field = val): WORKING
  - Field read (arr[i]\\field): WORKING
  - Loop iteration: WORKING
  - Float fields: WORKING
  - String fields: WORKING
  - Variable index: WORKING
  - Expressions: WORKING



--------------------------------------------------------------------------------
FILE: 46 test binomial transform.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
========================================
   BINOMIAL TRANSFORM TEST
========================================

=== Factorial Tests ===
0! = 1
1! = 1
5! = 120
6! = 720

=== Binomial Coefficient Tests ===
C(5,0) = 1
C(5,1) = 5
C(5,2) = 10
C(5,3) = 10
C(5,5) = 1
C(10,5) = 252

=== Forward/Inverse Transform Test ===
Original (Catalan): [1, 1, 2, 5, 14, 42, 132, 429]
Forward transform:  [1, 2, 5, 15, 51, 188, 731, 2950]
Inverse (recovered):[1, 1, 2, 5, 14, 42, 132, 429]
PASS: Forward then Inverse recovers original!

=== Self-Inverting Transform Test ===
Original: [1, 2, 3, 4, 5, 6]
First transform: [1, -1, 0, 0, 0, 0]
Second transform:[1, 2, 3, 4, 5, 6]
PASS: Self-inverting transform works!

========================================
   TEST COMPLETE
========================================


--------------------------------------------------------------------------------
FILE: 50 full test suite.lj
TYPE: SOURCE
--------------------------------------------------------------------------------
>>> SOURCE FILE MODIFIED
Previous hash: ca127ca787ceadf2eaf9e48ebd7a6e85
Current hash:  de4cc506d7b3095c8b765bddb8dbab5a

--- PREVIOUS OUTPUT ---
========================================
   LJ2 FULL TEST SUITE (V1.023.26)
========================================

=== 1. Deeply Nested Expressions ===
  PASS: Nested parens basic
        expected=2 actual=2
  PASS: Nested all ops
        expected=15 actual=15
  PASS: Quadruple negation
        expected=5 actual=5
  PASS: Nested boolean
        expected=1 actual=1

=== 2. Chained Logic Operations ===
  PASS: Triple AND chain
        expected=1 actual=1
  PASS: Triple OR chain
        expected=1 actual=1
  PASS: Mixed AND/OR
        expected=1 actual=1
  PASS: NOT with OR
        expected=1 actual=1

=== 3. Operator Precedence Edge Cases ===
  PASS: Mul before add
        expected=14 actual=14
  PASS: Div before sub
        expected=17 actual=17
  PASS: Neg times neg
        expected=12 actual=12
  PASS: Modulo then add
        expected=5 actual=5
  PASS: Complex precedence
        expected=15 actual=15

=== 4. Boundary Values ===
  PASS: Large multiply
        expected=1000000000 actual=1000000000
  PASS: Zero times large
        expected=0 actual=0
  PASS: Large times zero
        expected=0 actual=0
  PASS: Zero divided
        expected=0 actual=0
  PASS: N mod N
        expected=0 actual=0
  PASS: N-1 mod N
        expected=99 actual=99
  PASS: 1 mod N
        expected=1 actual=1

=== 5. Float Precision ===
  PASS: Small float scale up
        expected=1.000000 actual=1.000000 (diff=0.000000)
  PASS: Float accumulation
        expected=1.000000 actual=1.000000 (diff=0.000000)
  PASS: 1/3 * 3
        expected=1.000000 actual=1.000000 (diff=0.000000)
  PASS: Tiny squared
        expected=0.000000 actual=0.000000 (diff=0.000000)

=== 6. Recursive Functions ===
  PASS: Fibonacci 0
        expected=0 actual=0
  PASS: Fibonacci 1
        expected=1 actual=1
  PASS: Fibonacci 5
        expected=5 actual=5
  PASS: Fibonacci 10
        expected=55 actual=55
  PASS: Factorial 0
        expected=1 actual=1
  PASS: Factorial 1
        expected=1 actual=1
  PASS: Factorial 5
        expected=120 actual=120
  PASS: Factorial 7
        expected=5040 actual=5040
  PASS: Ackermann 0,0
        expected=1 actual=1
  PASS: Ackermann 1,1
        expected=3 actual=3
  PASS: Ackermann 2,2
        expected=7 actual=7
  PASS: Ackermann 3,2
        expected=29 actual=29

=== 7. Function Composition ===
  PASS: double(square(3))
        expected=18 actual=18
  PASS: square(double(3))
        expected=36 actual=36
  PASS: addTen(double(square(2)))
        expected=18 actual=18
  PASS: double(3)+square(4)
        expected=22 actual=22
  PASS: double(3)*square(2)
        expected=24 actual=24

=== 8. Control Flow Edge Cases ===
  PASS: Zero iteration loop
        expected=0 actual=0
  PASS: Single iteration loop
        expected=1 actual=1
  PASS: Nested 5x5 loop
        expected=25 actual=25
  PASS: Deep if-else chain
        expected=3 actual=3

=== 9. Ternary Operator ===
  PASS: Basic ternary true
        expected=100 actual=100
  PASS: Basic ternary false
        expected=200 actual=200
  PASS: Nested ternary
        expected=2 actual=2
  PASS: Ternary with expr true
        expected=30 actual=30
  PASS: Ternary with expr false
        expected=200 actual=200
  PASS: Ternary in function
        expected=42 actual=42
  PASS: Ternary in function false
        expected=99 actual=99

=== 10. Array Operations ===
  PASS: Array squares 0
        expected=0 actual=0
  PASS: Array squares 5
        expected=25 actual=25
  PASS: Array squares 9
        expected=81 actual=81
  PASS: Array sum of squares
        expected=285 actual=285
  PASS: Reverse array first
        expected=81 actual=81
  PASS: Reverse array last
        expected=0 actual=0

=== 11. String Operations ===
  PASS: String concat
        expected='Hello World' actual='Hello World'
  PASS: String with int
        expected='Value: 42' actual='Value: 42'
  PASS: Multi concat
        expected='WXYZ' actual='WXYZ'
  PASS: Empty prefix
        expected='test' actual='test'
  PASS: Empty suffix
        expected='test' actual='test'

=== 12. Structure Operations ===
  PASS: Struct init x
        expected=1.000000 actual=1.000000 (diff=0.000000)
  PASS: Struct init y
        expected=2.000000 actual=2.000000 (diff=0.000000)
  PASS: Struct init z
        expected=3.000000 actual=3.000000 (diff=0.000000)
  PASS: Struct modify x
        expected=10.000000 actual=10.000000 (diff=0.000000)
  PASS: Struct copy x
        expected=10.000000 actual=10.000000 (diff=0.000000)
  PASS: Struct copy y
        expected=2.000000 actual=2.000000 (diff=0.000000)
  PASS: Original unchanged
        expected=10.000000 actual=10.000000 (diff=0.000000)
  PASS: Copy changed
        expected=99.000000 actual=99.000000 (diff=0.000000)

=== 13. Pointer Operations ===
  PASS: Pointer deref
        expected=42 actual=42
  PASS: Modify via pointer
        expected=100 actual=100
  PASS: Array ptr [0]
        expected=10 actual=10
  PASS: Array ptr [1]
        expected=20 actual=20
  PASS: Array ptr [3]
        expected=40 actual=40

=== 14. Struct Pointers ===
  PASS: Struct ptr x
        expected=100 actual=100
  PASS: Struct ptr y
        expected=200 actual=200
  PASS: Modified via ptr
        expected=999 actual=999
  PASS: Func struct ptr x
        expected=1000 actual=1000
  PASS: Func struct ptr y
        expected=201 actual=201

=== 15. Mixed Type Arithmetic ===
  PASS: Int * float
        expected=12.500000 actual=12.500000 (diff=0.000000)
  PASS: Int + float
        expected=7.500000 actual=7.500000 (diff=0.000000)
  PASS: Int division to float
        expected=3.500000 actual=3.500000 (diff=0.000000)

=== 16. Special Values ===
  PASS: True is 1
        expected=1 actual=1
  PASS: False is 0
        expected=0 actual=0
  PASS: Not true
        expected=0 actual=0
  PASS: Not false
        expected=1 actual=1
  PASS: Not not true
        expected=1 actual=1
  PASS: Not not false
        expected=0 actual=0

=== 17. Loop Patterns ===
  PASS: Sum 1 to 100
        expected=5050 actual=5050
  PASS: 6! via loop
        expected=720 actual=720
  PASS: Evens 1-20
        expected=10 actual=10
  PASS: Max in sequence
        expected=11 actual=11

=== 18. GCD and LCM ===
  PASS: GCD 12,8
        expected=4 actual=4
  PASS: GCD 17,13
        expected=1 actual=1
  PASS: GCD 100,25
        expected=25 actual=25
  PASS: GCD 48,18
        expected=6 actual=6
  PASS: LCM 4,6
        expected=12 actual=12
  PASS: LCM 3,5
        expected=15 actual=15
  PASS: LCM 12,18
        expected=36 actual=36

=== 19. Prime Numbers ===
  PASS: isPrime 1
        expected=0 actual=0
  PASS: isPrime 2
        expected=1 actual=1
  PASS: isPrime 3
        expected=1 actual=1
  PASS: isPrime 4
        expected=0 actual=0
  PASS: isPrime 17
        expected=1 actual=1
  PASS: isPrime 18
        expected=0 actual=0
  PASS: isPrime 97
        expected=1 actual=1
  PASS: Primes <= 50
        expected=15 actual=15

=== 20. Bit Manipulation Simulation ===
  PASS: Bit 0 of 42
        expected=0 actual=0
  PASS: Bit 1 of 42
        expected=1 actual=1
  PASS: Bit 2 of 42
        expected=0 actual=0
  PASS: Bit 3 of 42
        expected=1 actual=1
  PASS: Bit 4 of 42
        expected=0 actual=0
  PASS: Bit 5 of 42
        expected=1 actual=1
  PASS: isPow2 1
        expected=1 actual=1
  PASS: isPow2 2
        expected=1 actual=1
  PASS: isPow2 3
        expected=0 actual=0
  PASS: isPow2 16
        expected=1 actual=1
  PASS: isPow2 17
        expected=0 actual=0
  PASS: isPow2 64
        expected=1 actual=1

========================================
           TEST RESULTS
========================================

Total Passed: 121
Total Failed: 0
Total Tests:  121

*** ALL TESTS PASSED! ***

========================================


+++ CURRENT OUTPUT +++
========================================
   LJ2 FULL TEST SUITE (V1.023.26)
========================================

=== 1. Deeply Nested Expressions ===
  PASS: Nested parens basic
        expected=2 actual=2
  PASS: Nested all ops
        expected=15 actual=15
  PASS: Quadruple negation
        expected=5 actual=5
  PASS: Nested boolean
        expected=1 actual=1

=== 2. Chained Logic Operations ===
  PASS: Triple AND chain
        expected=1 actual=1
  PASS: Triple OR chain
        expected=1 actual=1
  PASS: Mixed AND/OR
        expected=1 actual=1
  PASS: NOT with OR
        expected=1 actual=1

=== 3. Operator Precedence Edge Cases ===
  PASS: Mul before add
        expected=14 actual=14
  PASS: Div before sub
        expected=17 actual=17
  PASS: Neg times neg
        expected=12 actual=12
  PASS: Modulo then add
        expected=5 actual=5
  PASS: Complex precedence
        expected=15 actual=15

=== 4. Boundary Values ===
  PASS: Large multiply
        expected=1000000000 actual=1000000000
  PASS: Zero times large
        expected=0 actual=0
  PASS: Large times zero
        expected=0 actual=0
  PASS: Zero divided
        expected=0 actual=0
  PASS: N mod N
        expected=0 actual=0
  PASS: N-1 mod N
        expected=99 actual=99
  PASS: 1 mod N
        expected=1 actual=1

=== 5. Float Precision ===
  PASS: Small float scale up
        expected=1.000000 actual=1.000000 (diff=0.000000)
  PASS: Float accumulation
        expected=1.000000 actual=1.000000 (diff=0.000000)
  PASS: 1/3 * 3
        expected=1.000000 actual=1.000000 (diff=0.000000)
  PASS: Tiny squared
        expected=0.000000 actual=0.000000 (diff=0.000000)

=== 6. Recursive Functions ===
  PASS: Fibonacci 0
        expected=0 actual=0
  PASS: Fibonacci 1
        expected=1 actual=1
  PASS: Fibonacci 5
        expected=5 actual=5
  PASS: Fibonacci 10
        expected=55 actual=55
  PASS: Factorial 0
        expected=1 actual=1
  PASS: Factorial 1
        expected=1 actual=1
  PASS: Factorial 5
        expected=120 actual=120
  PASS: Factorial 7
        expected=5040 actual=5040
  PASS: Ackermann 0,0
        expected=1 actual=1
  PASS: Ackermann 1,1
        expected=3 actual=3
  PASS: Ackermann 2,2
        expected=7 actual=7
  PASS: Ackermann 3,2
        expected=29 actual=29

=== 7. Function Composition ===
  PASS: double(square(3))
        expected=18 actual=18
  PASS: square(double(3))
        expected=36 actual=36
  PASS: addTen(double(square(2)))
        expected=18 actual=18
  PASS: double(3)+square(4)
        expected=22 actual=22
  PASS: double(3)*square(2)
        expected=24 actual=24

=== 8. Control Flow Edge Cases ===
  PASS: Zero iteration loop
        expected=0 actual=0
  PASS: Single iteration loop
        expected=1 actual=1
  PASS: Nested 5x5 loop
        expected=25 actual=25
  PASS: Deep if-else chain
        expected=3 actual=3

=== 9. Ternary Operator ===
  PASS: Basic ternary true
        expected=100 actual=100
  PASS: Basic ternary false
        expected=200 actual=200
  PASS: Nested ternary
        expected=2 actual=2
  PASS: Ternary with expr true
        expected=30 actual=30
  PASS: Ternary with expr false
        expected=200 actual=200
  PASS: Ternary in function
        expected=42 actual=42
  PASS: Ternary in function false
        expected=99 actual=99

=== 10. Array Operations ===
  PASS: Array squares 0
        expected=0 actual=0
  PASS: Array squares 5
        expected=25 actual=25
  PASS: Array squares 9
        expected=81 actual=81
  PASS: Array sum of squares
        expected=285 actual=285
  PASS: Reverse array first
        expected=81 actual=81
  PASS: Reverse array last
        expected=0 actual=0

=== 11. String Operations ===
  PASS: String concat
        expected='Hello World' actual='Hello World'
  PASS: String with int
        expected='Value: 42' actual='Value: 42'
  PASS: Multi concat
        expected='WXYZ' actual='WXYZ'
  PASS: Empty prefix
        expected='test' actual='test'
  PASS: Empty suffix
        expected='test' actual='test'

=== 12. Structure Operations ===
  PASS: Struct init x
        expected=1.000000 actual=1.000000 (diff=0.000000)
  PASS: Struct init y
        expected=2.000000 actual=2.000000 (diff=0.000000)
  PASS: Struct init z
        expected=3.000000 actual=3.000000 (diff=0.000000)
  PASS: Struct modify x
        expected=10.000000 actual=10.000000 (diff=0.000000)
  PASS: Struct copy x
        expected=10.000000 actual=10.000000 (diff=0.000000)
  PASS: Struct copy y
        expected=2.000000 actual=2.000000 (diff=0.000000)
  PASS: Original unchanged
        expected=10.000000 actual=10.000000 (diff=0.000000)
  PASS: Copy changed
        expected=99.000000 actual=99.000000 (diff=0.000000)

=== 13. Pointer Operations ===
  PASS: Pointer deref
        expected=42 actual=42
  PASS: Modify via pointer
        expected=100 actual=100
  PASS: Array ptr [0]
        expected=10 actual=10
  PASS: Array ptr [1]
        expected=20 actual=20
  PASS: Array ptr [3]
        expected=40 actual=40

=== 14. Struct Pointers ===
  PASS: Struct ptr x
        expected=100 actual=100
  PASS: Struct ptr y
        expected=200 actual=200
  PASS: Modified via ptr
        expected=999 actual=999
  PASS: Func struct ptr x
        expected=1000 actual=1000
  PASS: Func struct ptr y
        expected=201 actual=201

=== 15. Mixed Type Arithmetic ===
  PASS: Int * float
        expected=12.500000 actual=12.500000 (diff=0.000000)
  PASS: Int + float
        expected=7.500000 actual=7.500000 (diff=0.000000)
  PASS: Int division to float
        expected=3.500000 actual=3.500000 (diff=0.000000)

=== 16. Special Values ===
  PASS: True is 1
        expected=1 actual=1
  PASS: False is 0
        expected=0 actual=0
  PASS: Not true
        expected=0 actual=0
  PASS: Not false
        expected=1 actual=1
  PASS: Not not true
        expected=1 actual=1
  PASS: Not not false
        expected=0 actual=0

=== 17. Loop Patterns ===
  PASS: Sum 1 to 100
        expected=5050 actual=5050
  PASS: 6! via loop
        expected=720 actual=720
  PASS: Evens 1-20
        expected=10 actual=10
  PASS: Max in sequence
        expected=11 actual=11

=== 18. GCD and LCM ===
  PASS: GCD 12,8
        expected=4 actual=4
  PASS: GCD 17,13
        expected=1 actual=1
  PASS: GCD 100,25
        expected=25 actual=25
  PASS: GCD 48,18
        expected=6 actual=6
  PASS: LCM 4,6
        expected=12 actual=12
  PASS: LCM 3,5
        expected=15 actual=15
  PASS: LCM 12,18
        expected=36 actual=36

=== 19. Prime Numbers ===
  PASS: isPrime 1
        expected=0 actual=0
  PASS: isPrime 2
        expected=1 actual=1
  PASS: isPrime 3
        expected=1 actual=1
  PASS: isPrime 4
        expected=0 actual=0
  PASS: isPrime 17
        expected=1 actual=1
  PASS: isPrime 18
        expected=0 actual=0
  PASS: isPrime 97
        expected=1 actual=1
  PASS: Primes <= 50
        expected=15 actual=15

=== 20. Bit Manipulation Simulation ===
  PASS: Bit 0 of 42
        expected=0 actual=0
  PASS: Bit 1 of 42
        expected=1 actual=1
  PASS: Bit 2 of 42
        expected=0 actual=0
  PASS: Bit 3 of 42
        expected=1 actual=1
  PASS: Bit 4 of 42
        expected=0 actual=0
  PASS: Bit 5 of 42
        expected=1 actual=1
  PASS: isPow2 1
        expected=1 actual=1
  PASS: isPow2 2
        expected=1 actual=1
  PASS: isPow2 3
        expected=0 actual=0
  PASS: isPow2 16
        expected=1 actual=1
  PASS: isPow2 17
        expected=0 actual=0
  PASS: isPow2 64
        expected=1 actual=1

========================================
           TEST RESULTS
========================================

Total Passed: 121
Total Failed: 0
Total Tests:  121

*** ALL TESTS PASSED! ***

========================================


--------------------------------------------------------------------------------
FILE: 51 AVL tree.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
========================================
        AVL Tree Demonstration
========================================

Inserting: 10, 20, 30, 40, 50, 25

Tree structure (rotated, right is up):
        50(h=1,b=0)
    40(h=2,b=-1)
30(h=3,b=0)
        25(h=1,b=0)
    20(h=2,b=0)
        10(h=1,b=0)

In-order traversal (sorted): 
10 
20 
25 
30 
40 
50 


Pre-order traversal: 
30 
20 
10 
25 
40 
50 


Verifying AVL property...
AVL property: VALID
Node count: 6

Search tests:
  find(30) = 1 (expected 1)
  find(25) = 1 (expected 1)
  find(99) = 0 (expected 0)

Deleting 20...
Tree structure (rotated, right is up):
        50(h=1,b=0)
    40(h=2,b=-1)
30(h=3,b=0)
    25(h=2,b=1)
        10(h=1,b=0)

In-order after delete: 
10 
25 
30 
40 
50 


Verifying AVL after delete...
AVL property: VALID

Inserting: 5, 15, 35, 45
Tree structure (rotated, right is up):
        50(h=2,b=1)
            45(h=1,b=0)
    40(h=3,b=-1)
        35(h=1,b=0)
30(h=4,b=0)
        25(h=2,b=1)
            15(h=1,b=0)
    10(h=3,b=-1)
        5(h=1,b=0)

Final in-order: 
5 
10 
15 
25 
30 
35 
40 
45 
50 


Final verification...
AVL property: VALID
Total nodes: 9

========================================
        AVL Tree Demo Complete
========================================


--------------------------------------------------------------------------------
FILE: 52 test lists.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
=== LIST TEST (V1.026.0) ===

TEST 1: List Declaration
------------------------
  Integer list 'numbers' declared
  String list 'names' declared
  Float list 'values' declared
  PASS: List declarations work!

TEST 2: Add Elements
-------------------
  Added 10, 20, 30 to numbers list
  List size: 3
[PASS] assertEqual: 3 == 3
  PASS: listAdd and listSize work!

TEST 3: Navigation
-----------------
  listFirst returned: 1
[PASS] assertEqual: 1 == 1
  First element: 10
[PASS] assertEqual: 10 == 10
  Next element: 20
[PASS] assertEqual: 20 == 20
  Next element: 30
[PASS] assertEqual: 30 == 30
  Next after last: 0
[PASS] assertEqual: 0 == 0
  PASS: Navigation works!

TEST 4: Last and Prev
--------------------
  Last element: 30
[PASS] assertEqual: 30 == 30
  Prev element: 20
[PASS] assertEqual: 20 == 20
  PASS: listLast and listPrev work!

TEST 5: listSet
--------------
  Set first to 100, got: 100
[PASS] assertEqual: 100 == 100
  PASS: listSet works!

TEST 6: Index and Select
-----------------------
  Current index: 0
[PASS] assertEqual: 0 == 0
  Selected index 2, value: 30
[PASS] assertEqual: 30 == 30
  PASS: listIndex and listSelect work!

TEST 7: Iteration
----------------
  Elements:
    100
    20
    30
  PASS: Iteration works!

TEST 8: String List
------------------
  Added Alice, Bob, Charlie to names list
  String list size: 3
[PASS] assertEqual: 3 == 3
  First name: Alice
[PASS] assertStringEqual: "Alice" == "Alice"
  Second name: Bob
[PASS] assertStringEqual: "Bob" == "Bob"
  Last name: Charlie
[PASS] assertStringEqual: "Charlie" == "Charlie"
  Set first to Alicia, got: Alicia
[PASS] assertStringEqual: "Alicia" == "Alicia"
  PASS: String list works!

TEST 9: String List Iteration
----------------------------
  Names:
    Alicia
    Bob
    Charlie
  PASS: String iteration works!

=== ALL LIST TESTS PASSED ===


--------------------------------------------------------------------------------
FILE: 53 test maps.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
=== MAP TEST (V1.026.0) ===

TEST 1: Map Declaration
-----------------------
  Integer map 'ages' declared (string -> int)
  String map 'labels' declared (string -> string)
  Float map 'scores' declared (string -> float)
  PASS: Map declarations work!

TEST 2: Put/Get Operations
-------------------------
  Added Alice=30, Bob=25, Charlie=35
  Alice's age: 30
[PASS] assertEqual: 30 == 30
  Bob's age: 25
[PASS] assertEqual: 25 == 25
  Charlie's age: 35
[PASS] assertEqual: 35 == 35
  PASS: mapPut and mapGet work!

TEST 3: Map Size
---------------
  Map size: 3
[PASS] assertEqual: 3 == 3
  PASS: mapSize works!

TEST 4: mapContains
------------------
  Contains 'Alice': 1
[PASS] assertEqual: 1 == 1
  Contains 'Unknown': 0
[PASS] assertEqual: 0 == 0
  PASS: mapContains works!

TEST 5: Update Key
-----------------
  Updated Alice to 31, got: 31
[PASS] assertEqual: 31 == 31
  PASS: Update works!

TEST 6: mapDelete
----------------
  Deleted Bob, contains: 0
[PASS] assertEqual: 0 == 0
  Size after delete: 2
[PASS] assertEqual: 2 == 2
  PASS: mapDelete works!

TEST 7: Non-existent Key
-----------------------
  Get 'Nobody': 0
[PASS] assertEqual: 0 == 0
  PASS: Non-existent returns 0!

TEST 8: Map Iteration
--------------------
  Entries:
    Charlie = 35
    Alice = 31
  PASS: Iteration works!

TEST 9: mapClear
---------------
  Size after clear: 0
[PASS] assertEqual: 0 == 0
  PASS: mapClear works!

TEST 10: String Map
------------------
  Added btn1=Submit, btn2=Cancel, btn3=Help
  btn1 label: Submit
[PASS] assertStringEqual: "Submit" == "Submit"
  btn2 label: Cancel
[PASS] assertStringEqual: "Cancel" == "Cancel"
  btn3 label: Help
[PASS] assertStringEqual: "Help" == "Help"
  String map size: 3
[PASS] assertEqual: 3 == 3
  PASS: String map put/get works!

TEST 11: String Map Update
-------------------------
  Updated btn1 to OK, got: OK
[PASS] assertStringEqual: "OK" == "OK"
  Contains 'btn2': 1
[PASS] assertEqual: 1 == 1
  Contains 'btn99': 0
[PASS] assertEqual: 0 == 0
  PASS: String map update and contains work!

TEST 12: String Map Iteration
----------------------------
  Labels:
    btn1 = OK
    btn2 = Cancel
    btn3 = Help
  PASS: String map iteration works!

TEST 13: String Map Delete/Clear
-------------------------------
  Deleted btn2, contains: 0
[PASS] assertEqual: 0 == 0
  Size after delete: 2
[PASS] assertEqual: 2 == 2
  Size after clear: 0
[PASS] assertEqual: 0 == 0
  PASS: String map delete/clear works!

=== ALL MAP TESTS PASSED ===


--------------------------------------------------------------------------------
FILE: 54 test local collections.lj
TYPE: NEW
--------------------------------------------------------------------------------
>>> NEW TEST - No previous output to compare

Current output:
=== LOCAL COLLECTIONS TEST (V1.026.8) ===

TEST 1: Local Integer List
--------------------------
  Added 10, 20, 30
  Size: 3
[PASS] assertEqual: 3 == 3
  First: 10
[PASS] assertEqual: 10 == 10
  Second: 20
[PASS] assertEqual: 20 == 20
  Last: 30
[PASS] assertEqual: 30 == 30
  Set first to 100, got: 100
[PASS] assertEqual: 100 == 100
  Iteration:
    100
    20
    30
  PASS: Local int list works!

TEST 2: Local String List
-------------------------
  Added Apple, Banana, Cherry
  Size: 0
[FAIL] assertEqual: expected 0 but got 3
  First: Cherry
[FAIL] assertStringEqual: expected "Cherry" but got "Apple"
  Last: Apple
[FAIL] assertStringEqual: expected "Apple" but got "Cherry"
  Set first to Apricot, got: Cherry
[FAIL] assertStringEqual: expected "Cherry" but got "Apricot"
  Iteration:
  PASS: Local string list works!

TEST 3: Local Float List
------------------------
  Added 1.5, 2.75, 3.99
  Size: 0
[FAIL] assertEqual: expected 0 but got 3
  First:   First: 
  Last:   Last: 
  PASS: Local float list works!

TEST 4: Local Integer Map
-------------------------
  Added Alice=95, Bob=87, Charlie=92
  Size: 3
[PASS] assertEqual: 3 == 3
  Alice's score: 95
[PASS] assertEqual: 95 == 95
  Bob's score: 87
[PASS] assertEqual: 87 == 87
  Contains Charlie: 1
[PASS] assertEqual: 1 == 1
  Contains David: 0
[PASS] assertEqual: 0 == 0
  Updated Alice to 100, got: 100
[PASS] assertEqual: 100 == 100
  Deleted Bob, contains: 0
[PASS] assertEqual: 0 == 0
  Size after delete: 2
[PASS] assertEqual: 2 == 2
  Iteration:
    Charlie = 92
    Alice = 100
  PASS: Local int map works!

TEST 5: Local String Map
------------------------
  Added ok=OK, cancel=Cancel, help=Help
  Size: 0
[FAIL] assertEqual: expected 0 but got 3
  'ok' label:   Size: 
[FAIL] assertStringEqual: expected "  Size: " but got "OK"
  'cancel' label:   Size: 
[FAIL] assertStringEqual: expected "  Size: " but got "Cancel"
  Updated 'ok' to Okay, got:   Size: 
[FAIL] assertStringEqual: expected "  Size: " but got "Okay"
  Iteration:
  Size after clear: 0
[PASS] assertEqual: 0 == 0
  PASS: Local string map works!

TEST 6: Local Float Map
-----------------------
  Added USD=1.0, EUR=0.92, GBP=0.79
  Size: 0
[FAIL] assertEqual: expected 0 but got 3
  EUR rate: 0.000
  GBP rate: 0.000
  PASS: Local float map works!

TEST 7: Multiple Collections
----------------------------
[PASS] assertEqual: 2 == 2
[PASS] assertEqual: 2 == 2
[PASS] assertEqual: 2 == 2
[PASS] assertEqual: 2 == 2
  All 4 collections created and populated
  intList first: 1
[PASS] assertEqual: 1 == 1
  strList first: X
[PASS] assertStringEqual: "X" == "X"
  intMap['a']: 10
[PASS] assertEqual: 10 == 10
  strMap['p']: P-value
[PASS] assertStringEqual: "P-value" == "P-value"
  PASS: Multiple collections work!

TEST 8: Nested Function Calls
-----------------------------
  innerFunc(10) = 0 (expected 60)
[FAIL] assertEqual: expected 0 but got 60
  innerFunc(5) = 0 (expected 30)
[FAIL] assertEqual: expected 0 but got 30
  innerFunc(3) = 0 (expected 18)
[FAIL] assertEqual: expected 0 but got 18
  Results list size: 3
[PASS] assertEqual: 3 == 3
  PASS: Nested calls work!

=== ALL LOCAL COLLECTION TESTS PASSED ===


================================================================================
END OF DIFF REPORT
================================================================================
